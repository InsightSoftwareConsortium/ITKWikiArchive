<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>SimpleITK/Advisory Review Board/Prototype Code Discussions - KitwarePublic</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":!1,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"ac9ff094b751b3abba25c93e","wgCSPNonce":!1,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":!1,"wgNamespaceNumber":0,"wgPageName":"SimpleITK/Advisory_Review_Board/Prototype_Code_Discussions","wgTitle":"SimpleITK/Advisory Review Board/Prototype Code Discussions","wgCurRevisionId":51427,"wgRevisionId":51427,"wgArticleId":6879,"wgIsArticle":!0,"wgIsRedirect":!1,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"SimpleITK/Advisory_Review_Board/Prototype_Code_Discussions","wgRelevantArticleId":6879,"wgIsProbablyEditable":!1,
"wgRelevantPageIsProbablyEditable":!1,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRedirectedFrom":"ITK/Release_4/SimpleITK/Advisory_Review_Board/Prototype_Code_Discussions","wgInternalRedirectTargetUrl":"/Wiki/SimpleITK/Advisory_Review_Board/Prototype_Code_Discussions"};RLSTATE={"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"loading","skins.monobook.styles":"ready"};RLPAGEMODULES=["mediawiki.action.view.redirect","site","mediawiki.page.ready","mediawiki.toc","skins.monobook.scripts"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@1hzgi",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});});</script>
<link rel="stylesheet" href="/Wiki/load.php?lang=en&amp;modules=skins.monobook.styles&amp;only=styles&amp;skin=monobook"/>
<script async="" src="/Wiki/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=monobook"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="/Wiki/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=monobook"/>
<meta name="generator" content="MediaWiki 1.37.1"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0"/>
<link rel="shortcut icon" href="/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="/Wiki/opensearch_desc.php" title="KitwarePublic (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://public.kitware.com/Wiki/api.php?action=rsd"/>
<link rel="license" href="https://creativecommons.org/licenses/by/2.5/"/>
<link rel="alternate" type="application/atom+xml" title="KitwarePublic Atom feed" href="/Wiki/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<link rel="canonical" href="https://public.kitware.com/Wiki/SimpleITK/Advisory_Review_Board/Prototype_Code_Discussions"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-SimpleITK_Advisory_Review_Board_Prototype_Code_Discussions rootpage-SimpleITK skin-monobook action-view skin--responsive"><!-- start content -->
				<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#General_Design_Questions"><span class="tocnumber">1</span> <span class="toctext">General Design Questions</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Procedural_-vs-_Pipelined"><span class="tocnumber">1.1</span> <span class="toctext">Procedural -vs- Pipelined</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Enums_-vs-_Parameter_methods"><span class="tocnumber">1.2</span> <span class="toctext">Enums -vs- Parameter methods</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Registration_granularity"><span class="tocnumber">1.3</span> <span class="toctext">Registration granularity</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Streaming"><span class="tocnumber">1.4</span> <span class="toctext">Streaming</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Simple_Examples"><span class="tocnumber">2</span> <span class="toctext">Simple Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="#Gaussian_Blur"><span class="tocnumber">2.1</span> <span class="toctext">Gaussian Blur</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="#Procedural"><span class="tocnumber">2.1.1</span> <span class="toctext">Procedural</span></a>
<ul>
<li class="toclevel-4 tocsection-9"><a href="#Jim&#39;s_recommendation"><span class="tocnumber">2.1.1.1</span> <span class="toctext">Jim's recommendation</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-10"><a href="#Filter_Blocks"><span class="tocnumber">2.1.2</span> <span class="toctext">Filter Blocks</span></a>
<ul>
<li class="toclevel-4 tocsection-11"><a href="#Jim&#39;s_recommendation_2"><span class="tocnumber">2.1.2.1</span> <span class="toctext">Jim's recommendation</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-12"><a href="#Pipelined"><span class="tocnumber">2.1.3</span> <span class="toctext">Pipelined</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-13"><a href="#Image_Registration"><span class="tocnumber">2.2</span> <span class="toctext">Image Registration</span></a>
<ul>
<li class="toclevel-3 tocsection-14"><a href="#Procedural_2"><span class="tocnumber">2.2.1</span> <span class="toctext">Procedural</span></a>
<ul>
<li class="toclevel-4 tocsection-15"><a href="#Jim&#39;s_recommendation_3"><span class="tocnumber">2.2.1.1</span> <span class="toctext">Jim's recommendation</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-16"><a href="#Filter_blocks_2"><span class="tocnumber">2.2.2</span> <span class="toctext">Filter blocks</span></a>
<ul>
<li class="toclevel-4 tocsection-17"><a href="#Jim&#39;s_recommendation_4"><span class="tocnumber">2.2.2.1</span> <span class="toctext">Jim's recommendation</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-18"><a href="#Pipeline"><span class="tocnumber">2.2.3</span> <span class="toctext">Pipeline</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#Strategy_pattern"><span class="tocnumber">2.2.4</span> <span class="toctext">Strategy pattern</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-20"><a href="#Level_Set"><span class="tocnumber">2.3</span> <span class="toctext">Level Set</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Region_Growing"><span class="tocnumber">2.4</span> <span class="toctext">Region Growing</span></a>
<ul>
<li class="toclevel-3 tocsection-22"><a href="#Procedural_3"><span class="tocnumber">2.4.1</span> <span class="toctext">Procedural</span></a>
<ul>
<li class="toclevel-4 tocsection-23"><a href="#Jim&#39;s_recommendation_5"><span class="tocnumber">2.4.1.1</span> <span class="toctext">Jim's recommendation</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-24"><a href="#Pipieline"><span class="tocnumber">2.4.2</span> <span class="toctext">Pipieline</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-25"><a href="#Watershed"><span class="tocnumber">2.5</span> <span class="toctext">Watershed</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#QuadEdgeMesh"><span class="tocnumber">2.6</span> <span class="toctext">QuadEdgeMesh</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-27"><a href="#User_Domain_Examples"><span class="tocnumber">3</span> <span class="toctext">User Domain Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-28"><a href="#Microscopy"><span class="tocnumber">3.1</span> <span class="toctext">Microscopy</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="#Orfeo_Toolbox"><span class="tocnumber">3.2</span> <span class="toctext">Orfeo Toolbox</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#Education"><span class="tocnumber">3.3</span> <span class="toctext">Education</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="General_Design_Questions">General Design Questions</span></h2>
<h4><span class="mw-headline" id="Procedural_-vs-_Pipelined">Procedural -vs- Pipelined</span></h4>
<ul><li>The <b>procedural</b> model sees each filter as an independent function that takes a set of inputs and produces an output.
<ul><li>Could either be purely functional (static functions, no need to instantiate a filter) or set up with blocks of code for each filter</li>
<li>Generally easier to learn than the pipelined model (similar to Matlab's style)</li></ul></li>
<li>The <b>pipelined</b> model sees each filter as a step along an algorithm pipeline that can take the output of a previous filter, modify it, and pass it off to the next filter in line.
<ul><li>Largely a mirror of the current ITK implementation with the templates hidden</li>
<li>Can be used to stream large images</li></ul></li></ul>
<h4><span class="mw-headline" id="Enums_-vs-_Parameter_methods">Enums -vs- Parameter methods</span></h4>
<ul><li>This refers to the convention for setting filter parameters</li>
<li><b>enums</b> =&gt; filter.SetParameter("name", val);
<ul><li>Single method or a set of type specific methods used throughout toolkit</li></ul></li>
<li><b>parameter methods</b> =&gt; filter.Set<i>Name</i>(val);
<ul><li>This is how it's currently done in ITK</li></ul></li></ul>
<h4><span class="mw-headline" id="Registration_granularity">Registration granularity</span></h4>
<ul><li>Should transform, metric, optimizer, interpolation be modular like in ITK?</li></ul>
<h4><span class="mw-headline" id="Streaming">Streaming</span></h4>
<ul><li>An open question is how Filter Blocks / Procedural paradigm might support streaming.  Based on Jim Miller's suggestion, we could build machinery to stream blocks through a list of filters.  This assumes the readers and writers support random access to images on disk.</li></ul>
<h2><span class="mw-headline" id="Simple_Examples">Simple Examples</span></h2>
<h3><span class="mw-headline" id="Gaussian_Blur">Gaussian Blur</span></h3>
<ul><li>Open an image</li>
<li>Filter the image with a Gaussian blur using sigma = 2</li>
<li>Write the image back out</li></ul>
<h4><span class="mw-headline" id="Procedural">Procedural</span></h4>
<ul><li>Pros:
<ul><li>Fewest lines of code to get a job done</li>
<li>Easy to learn/use ("Matlab-like")</li></ul></li>
<li>Cons:
<ul><li>Biggest diversion from traditional ITK style</li>
<li>Potentially long list of parameters for a given function</li></ul></li></ul>
<pre style="display: inline-block;">// Read the image
Image::Pointer im = ImageFileReader ("sample/path/to/image.jpg");

// Apply Gaussian with sigma = 2
im = GaussianFilter (im, 2);

// Write out the image
ImageFileWriter (im, "sample/path/to/output.png");
</pre>
<h5><span id="Jim.27s_recommendation"></span><span class="mw-headline" id="Jim's_recommendation">Jim's recommendation</span></h5>
<pre style="display: inline-block;">// Read the image
Image::Pointer im = ImageFileReader ("sample/path/to/image.jpg");

// Apply Gaussian with sigma = 2
im = GaussianFilter (im, 2);

// Write out the image
ImageFileWriter ("sample/path/to/output.png", im);
</pre>
<h4><span class="mw-headline" id="Filter_Blocks">Filter Blocks</span></h4>
<ul><li>Pros:
<ul><li>Each filter processes an image directly</li>
<li>Default parameters make provide good guess for algorithm prototyping</li>
<li>Parameters can be changed individually as needed</li></ul></li>
<li>Cons:
<ul><li>Image is fully processed between each filter (No easy streaming implementation)</li></ul></li>
<li>Other Notes:
<ul><li>No pipeline</li>
<li>Uses object-oriented paradigm so filters must be instantiated</li></ul></li></ul>
<p><br />
</p>
<pre style="display: inline-block;">// Read the image
ImageFileReader reader;
reader.SetFilename( "sample/path/to/image.jpg" );
Image::Pointer im = reader.Execute();

// Anonymous reader object
Image::Pointer im = ImageFileReader().SetFilename ( "path/image.nrrd" ).Execute();


// Apply Gaussian with sigma = 2
Gaussian filter;
filter.SetSigma( 2 );
im = filter.Execute( im );

// Write out the image
ImageFileWriter writer;
writer.SetFilename( "sample/path/to/output.png" );
writer.Execute( im );
</pre>
<h5><span id="Jim.27s_recommendation_2"></span><span class="mw-headline" id="Jim's_recommendation_2">Jim's recommendation</span></h5>
<pre style="display: inline-block;">// Read the image
ImageFileReader reader;
reader.SetFilename( "sample/path/to/image.jpg" );
Image::Pointer im = reader.Read();

// Apply Gaussian with sigma = 2
Gaussian filter;
filter.SetSigma( 2 );
im = filter.Filter( im );

// Write out the image
ImageFileWriter writer;
writer.SetFilename( "sample/path/to/output.png" );
writer.Write( im );
</pre>
<h4><span class="mw-headline" id="Pipelined">Pipelined</span></h4>
<ul><li>Pros:
<ul><li>Can easily implement streaming for large images</li>
<li>Default parameter list is good for prototyping</li>
<li>Can set individual parameters as needed</li></ul></li>
<li>Cons:
<ul><li>Pipeline paradigm may be steeper on-ramp for new users</li></ul></li>
<li>Other Notes:
<ul><li>Closest to full ITK implementation with templates removed</li></ul></li></ul>
<pre style="display: inline-block;">// Read the image
ImageFileReader reader;
reader.SetFilename( "sample/path/to/image.jpg" );

// Apply Gaussian with sigma = 2
Gaussian filter;
filter.SetSigma( 2 );
filter.SetInput( reader.getOutput() );

// Write out the image
ImageFileWriter writer;
writer.SetFilename( "sample/path/to/output.png" );
writer.SetInput( filter-&gt;GetOutput() );

// Execute the pipieline
writer.Update();
</pre>
<h3><span class="mw-headline" id="Image_Registration">Image Registration</span></h3>
<ul><li>Open two images (one fixed, one moving)</li>
<li>Register the moving image to the fixed image using affine registration</li>
<li>Resample the moving image using the computed transform</li>
<li>Write the resampled image out</li></ul>
<h4><span class="mw-headline" id="Procedural_2">Procedural</span></h4>
<ul><li>Pros:
<ul><li>Fewest lines of code</li></ul></li>
<li>Cons:
<ul><li>Long argument lists for functions</li>
<li>Not easily extensible w.r.t. transform type, optimization type, interpolation type, etc...</li></ul></li>
<li>Other Notees:
<ul><li>Most "Matlab-like"</li></ul></li></ul>
<pre style="display: inline-block;">// Open the fixed and moving images
Image::Pointer fixedImage = ImageFileReader::Execute( "path/to/fixed.jpg" );
Image::Pointer movingImage = ImageFileReader::Execute( "path/to/moving.jpg" );

// Register the moving image to the fixed image
AffineTransform::Pointer transform AffineRegistrator::Execute( fixedImage, movingImage );

// Resample the moving image
movingImage = ImageResampler::Execute( movingImage, transform );

// Write out the resampled image
ImageFileWriter::Ececute( movingImage, "path/to/output.png" );
</pre>
<h5><span id="Jim.27s_recommendation_3"></span><span class="mw-headline" id="Jim's_recommendation_3">Jim's recommendation</span></h5>
<pre style="display: inline-block;">// Open the fixed and moving images
Image::Pointer fixedImage = ImageFileReader::Read( "path/to/fixed.jpg" );
Image::Pointer movingImage = ImageFileReader::Read( "path/to/moving.jpg" );

// Register the moving image to the fixed image
AffineTransform::Pointer transform AffineRegistrator::Register( fixedImage, movingImage );

// Resample the moving image
movingImage = ImageResampler::Resample( movingImage, transform );

// Write out the resampled image
ImageFileWriter::Write( "path/to/output.png", movingImage );
</pre>
<h4><span class="mw-headline" id="Filter_blocks_2">Filter blocks</span></h4>
<ul><li>Pros:
<ul><li>Default parameters make provide good guess for algorithm prototyping</li>
<li>Parameters can be changed individually as needed</li></ul></li>
<li>Cons:
<ul><li>Image is fully processed when execute is called (No easy streaming implementation)</li></ul></li>
<li>Other Notes:
<ul><li>No pipeline</li>
<li>Uses object-oriented paradigm</li></ul></li></ul>
<pre style="display: inline-block;">// Open the fixed and moving images
ImageFileReader reader;
reader.SetFilename( "path/to/fixed.jpg" );
Image::Pointer fixedImage = reader.execute();
reader.SetFilename( "path/to/moving.jpg" );
Image::Pointer movingImage = reader.execute();

// Register the moving image to the fixed image
AffineRegistrator registrator;
registrator.SetFixedImage( fixedImage );
registrator.SetMovingImage( movingImage );
AffineTransform transform;
transform = registrator.execute();

// Resample the moving image
Resampler resampler;
resampler.SetTransform( transform );
movingImage = resampler.execute( movingImage );

// Write out the resampled image
ImageFileWriter writer;
writer.SetFilename( "path/to/output.png" );
writer.ececute( movingImage );
</pre>
<h5><span id="Jim.27s_recommendation_4"></span><span class="mw-headline" id="Jim's_recommendation_4">Jim's recommendation</span></h5>
<pre style="display: inline-block;">// Open the fixed and moving images
ImageFileReader reader;
reader.SetFilename( "path/to/fixed.jpg" );
Image::Pointer fixedImage = reader.Read();
reader.SetFilename( "path/to/moving.jpg" );
Image::Pointer movingImage = reader.Read();

// Register the moving image to the fixed image
AffineRegistrator registrator;
registrator.SetFixedImage( fixedImage );
registrator.SetMovingImage( movingImage );
AffineTransform transform;
transform = registrator.Register();

// Resample the moving image
Resampler resampler;
resampler.SetTransform( transform );
movingImage = resampler.Resample( movingImage );

// Write out the resampled image
ImageFileWriter writer;
writer.SetFilename( "path/to/output.png" );
writer.Write( movingImage );
</pre>
<h4><span class="mw-headline" id="Pipeline">Pipeline</span></h4>
<pre style="display: inline-block;">// Open the fixed and moving images
ImageFileReader reader1;
ImageFileReader reader2;
reader1.SetFilename( "path/to/fixed.jpg" );
reader2.SetFilename( "path/to/moving.jpg" );

// Register the moving image to the fixed image
AffineRegistrator registrator;
registrator.SetFixedImage( reader1.GetOutput() );
registrator.SetMovingImage( reader2.GetOutput() );

// Resample the moving image
Resampler resampler;
resampler.SetInput( reader2.GetOutput() );
resampler.SetTransform( registrator.GetOutput() );

// Write out the resampled image
ImageFileWriter writer;
writer.SetFilename( "path/to/output.png" );
writer.SetInput( movingImage );

// Execute the pipeline
writer.Update();
</pre>
<h4><span class="mw-headline" id="Strategy_pattern">Strategy pattern</span></h4>
<p><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Strategy_pattern">http://en.wikipedia.org/wiki/Strategy_pattern</a>
</p>
<ul><li>Notes:
<ul><li>2 independent issues here (strategy and parameter access)</li>
<li>Uses enums for parameter setting so all parameter setting is done through an X.SetParameter[TYPE]("name", val) function</li>
<li>Maintains registration granularity so that transform, interpolator, optimizer, and metric can be interchanged</li></ul></li></ul>
<pre style="display: inline-block;">// NOTE: Language = C#
// Create metric
itk::simple::simpleMetric metric;
metric.setType( itk::simple::MattesMutualInformation );
metric.setParameterInt( "NumberOfHistogramBins", 30 );
metric.setParameterInt( "NumberOfSpatialSamples", 1000 );

// Create interpolator
itk::simple::simpleInterpolator interpolator;
interpolator.setType( itk::simple::LanczosWindowedSincInterpolation );

// Create transform
itk::simple::simpleTransform transform;
transform.setType( itk::simple::AffineTransform );

// Create optimizer
itk::simple::simpleOptimizer optimizer;
optimizer.setType( itk::simple::RegularStepGradientDescentOptimizer );
optimizer.setParameterInt( "NumberOfIterations", 100 );
optimizer.setParameterDouble( "MinimumStepLength", 0.005 );
optimizer.setParameterDouble( "MaximumStepLength", 1.0 );
optimizer.setParameterBoolean( "Maximize", true );

// Registration
itk::simple::simpleRegistration registration;
registration.setMetric( metric );
registration.setInterpolator( interpolator );
registration.setTransform( transform );
registration.setOptimizer( optimizer );
registration.setFixedImage( fixedImage );
registration.setMovingImage( movingImage );
</pre>
<h3><span class="mw-headline" id="Level_Set">Level Set</span></h3>
<h3><span class="mw-headline" id="Region_Growing">Region Growing</span></h3>
<ul><li>Open an image</li>
<li>Set up a set of seed points</li>
<li>Run an connected threshold region growing segmentation</li>
<li>Write out the resulting segmentation mask</li></ul>
<h4><span class="mw-headline" id="Procedural_3">Procedural</span></h4>
<ul><li>Pros:
<ul><li>Fewest lines of code</li></ul></li>
<li>Cons:
<ul><li>Not modular</li>
<li>More complex argument lists needed for different comparison types</li></ul></li></ul>
<pre style="display: inline-block;">// Open an image
Image::Pointer im = ImageFileReader::Execute("sample/path/to/image.jpg");

// Set up seeds
std::vector&lt;Point&gt; points;
Point p1, p2;
p1[0] = 25;
p1[1] = 25;
p2[0] = 35;
p2[1] = 5;
points.push_back(p1);
points.push_back(p2);

// Run the region growing algorithm
seg = RegionGrowingConnectedThresholdFilter::Execute(im, points, 128, 200);

// Write out the resulting segmentation
ImageFileWriter::Execute(seg, "sample/path/to/output.png");
</pre>
<h5><span id="Jim.27s_recommendation_5"></span><span class="mw-headline" id="Jim's_recommendation_5">Jim's recommendation</span></h5>
<pre style="display: inline-block;">// Open an image
Image::Pointer im = ImageFileReader::Read("sample/path/to/image.jpg");

// Set up seeds
std::vector&lt;Point&gt; points;
Point p1, p2;
p1[0] = 25;
p1[1] = 25;
p2[0] = 35;
p2[1] = 5;
points.push_back(p1);
points.push_back(p2);

// Run the region growing algorithm
seg = RegionGrowingConnectedThresholdFilter::Filter(im, points, 128, 200); // Segment()?

// Write out the resulting segmentation
ImageFileWriter::Write( "sample/path/to/output.png", seg);
</pre>
<h4><span class="mw-headline" id="Pipieline">Pipieline</span></h4>
<ul><li>Pros:
<ul><li>Can implement streaming for large images</li>
<li>More efficient</li></ul></li>
<li>Cons:
<ul><li>Harder to learn that procedural</li></ul></li></ul>
<pre style="display: inline-block">// Open an image
ImageFileReader reader;
reader.SetFilename( "sample/path/to/image.jpg" );

// Set up seeds
std::vector&lt;Point&gt; points;
Point p1, p2;
p1[0] = 25;
p1[1] = 25;
p2[0] = 35;
p2[1] = 5;
points.push_back(p1);
points.push_back(p2);

// Set up the region growing algorithm
RegionGrowingConnectedThresholdFilter filter;
filter-&gt;SetInput(reader-&gt;GetOutput());
filter-&gt;SetSeedPoints(points);
filter-&gt;SetLower(128);
filter-&gt;SetUpper(200);

// Write out the image
ImageFileWriter writer;
writer.SetFilename( "sample/path/to/output.png" );
writer.SetInput( filter-&gt;GetOutput() );

// Update the pipieline
writer.Update();
</pre>
<h3><span class="mw-headline" id="Watershed">Watershed</span></h3>
<h3><span class="mw-headline" id="QuadEdgeMesh">QuadEdgeMesh</span></h3>
<h2><span class="mw-headline" id="User_Domain_Examples">User Domain Examples</span></h2>
<p>This section provides a set of examples for simple applications from a number of target user groups.  The goal is to present the ARB with targeted examples that show non-trivial applications specific to each target community.
</p>
<h3><span class="mw-headline" id="Microscopy">Microscopy</span></h3>
<h3><span class="mw-headline" id="Orfeo_Toolbox">Orfeo Toolbox</span></h3>
<h3><span class="mw-headline" id="Education">Education</span></h3>
<!-- 
NewPP limit report
Cached time: 20230204051715
Cache expiry: 86400
Reduced expiry: false
Complications: []
CPU time usage: 0.016 seconds
Real time usage: 0.017 seconds
Preprocessor visited node count: 159/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 8161/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key KitwarePublicWikiDB:pcache:idhash:6879-0!canonical and timestamp 20230204051715 and revision id 51427. Serialized with JSON.
 -->
</div>
<div class="printfooter">Retrieved from "<a dir="ltr" href="https://public.kitware.com/Wiki/index.php?title=SimpleITK/Advisory_Review_Board/Prototype_Code_Discussions&amp;oldid=51427">https://public.kitware.com/Wiki/index.php?title=SimpleITK/Advisory_Review_Board/Prototype_Code_Discussions&amp;oldid=51427</a>"</div></div>
				<div id="catlinks" class="catlinks catlinks-allhidden" data-mw="interface"></div>
				<!-- end content --></body></html>