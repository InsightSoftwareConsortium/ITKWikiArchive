<!DOCTYPE html>

<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="utf-8"/>
<title>ITK/Release 4/GPU Acceleration</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"e12c59497a035626112cd539","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"ITK/Release_4/GPU_Acceleration","wgTitle":"ITK/Release 4/GPU Acceleration","wgCurRevisionId":49012,"wgRevisionId":49012,"wgArticleId":8227,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"ITK/Release_4/GPU_Acceleration","wgRelevantArticleId":8227,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]};RLSTATE={"site.styles":
"ready","user.styles":"ready","user":"ready","user.options":"loading","skins.monobook.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.monobook.scripts"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@1i9g4",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link href="/Wiki/load.php?lang=en&amp;modules=skins.monobook.styles&amp;only=styles&amp;skin=monobook" rel="stylesheet"/>
<script async="" src="/Wiki/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=monobook"></script>
<meta content="" name="ResourceLoaderDynamicStyles"/>
<link href="/Wiki/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=monobook" rel="stylesheet"/>
<meta content="MediaWiki 1.38.6" name="generator"/>
<meta content="telephone=no" name="format-detection"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0" name="viewport"/>
<link href="/favicon.ico" rel="shortcut icon"/>
<link href="/Wiki/opensearch_desc.php" rel="search" title="KitwarePublic (en)" type="application/opensearchdescription+xml"/>
<link href="https://public.kitware.com/Wiki/api.php?action=rsd" rel="EditURI" type="application/rsd+xml"/>
<link href="https://creativecommons.org/licenses/by/2.5/" rel="license"/>
<link href="/Wiki/index.php?title=Special:RecentChanges&amp;feed=atom" rel="alternate" title="KitwarePublic Atom feed" type="application/atom+xml"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-ITK_Release_4_GPU_Acceleration rootpage-ITK skin-monobook action-view skin--responsive"><!-- start content -->
<div class="mw-body-content mw-content-ltr" dir="ltr" id="mw-content-text" lang="en"><div class="mw-parser-output"><p>This page outlines the proposed GPU acceleration framework in ITK v4. The GPU has become a cost-effective parallel computing platform for computationally expensive problems. Although many ITK image filters can benefit from the GPU, there has been no GPU support in ITK as of today. We propose to add a new data structure, framework, and some basic image operations that support the GPU in order to allow ITK developers to easily implement their filters running on both the CPU and GPU.
</p>
<div aria-labelledby="mw-toc-heading" class="toc" id="toc" role="navigation"><input class="toctogglecheckbox" id="toctogglecheckbox" role="button" style="display:none" type="checkbox"/><div class="toctitle" dir="ltr" lang="en"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Goals"><span class="tocnumber">1</span> <span class="toctext">Goals</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Authors"><span class="tocnumber">2</span> <span class="toctext">Authors</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Summary"><span class="tocnumber">3</span> <span class="toctext">Summary</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Example_Filters"><span class="tocnumber">4</span> <span class="toctext">Example Filters</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#New_Classes"><span class="tocnumber">5</span> <span class="toctext">New Classes</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#GPUImage"><span class="tocnumber">5.1</span> <span class="toctext">GPUImage</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#GPUDataManager"><span class="tocnumber">5.2</span> <span class="toctext">GPUDataManager</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="#GPUImageDataManager"><span class="tocnumber">5.2.1</span> <span class="toctext">GPUImageDataManager</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-9"><a href="#GPUContextManager"><span class="tocnumber">5.3</span> <span class="toctext">GPUContextManager</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#GPUKernelManager"><span class="tocnumber">5.4</span> <span class="toctext">GPUKernelManager</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#GPUImageToImageFilter"><span class="tocnumber">5.5</span> <span class="toctext">GPUImageToImageFilter</span></a>
<ul>
<li class="toclevel-3 tocsection-12"><a href="#GPUMeanImageFilter"><span class="tocnumber">5.5.1</span> <span class="toctext">GPUMeanImageFilter</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-13"><a href="#GPUInPlaceImageFilter"><span class="tocnumber">5.6</span> <span class="toctext">GPUInPlaceImageFilter</span></a>
<ul>
<li class="toclevel-3 tocsection-14"><a href="#GPUBinaryThresholdImageFilter"><span class="tocnumber">5.6.1</span> <span class="toctext">GPUBinaryThresholdImageFilter</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-15"><a href="#GPUFiniteDifferenceImageFilter"><span class="tocnumber">5.7</span> <span class="toctext">GPUFiniteDifferenceImageFilter</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="#Usage_Example"><span class="tocnumber">6</span> <span class="toctext">Usage Example</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#Latest_Code"><span class="tocnumber">7</span> <span class="toctext">Latest Code</span></a></li>
<li class="toclevel-1 tocsection-18"><a href="#ToDo_List"><span class="tocnumber">8</span> <span class="toctext">ToDo List</span></a></li>
<li class="toclevel-1 tocsection-19"><a href="#Plans"><span class="tocnumber">9</span> <span class="toctext">Plans</span></a>
<ul>
<li class="toclevel-2 tocsection-20"><a href="#GPU_image_class"><span class="tocnumber">9.1</span> <span class="toctext">GPU image class</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#GPU_support_for_ITK_multithreading_model"><span class="tocnumber">9.2</span> <span class="toctext">GPU support for ITK multithreading model</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#Filter_API_to_support_GPU_code"><span class="tocnumber">9.3</span> <span class="toctext">Filter API to support GPU code</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Basic_GPU_image_operators"><span class="tocnumber">9.4</span> <span class="toctext">Basic GPU image operators</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#Wish_List_of_Classes_to_Support_GPU"><span class="tocnumber">9.5</span> <span class="toctext">Wish List of Classes to Support GPU</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-25"><a href="#Target_architecture"><span class="tocnumber">10</span> <span class="toctext">Target architecture</span></a></li>
<li class="toclevel-1 tocsection-26"><a href="#Instructions_for_Installing_OpenCL"><span class="tocnumber">11</span> <span class="toctext">Instructions for Installing OpenCL</span></a></li>
<li class="toclevel-1 tocsection-27"><a href="#Tcons"><span class="tocnumber">12</span> <span class="toctext">Tcons</span></a></li>
</ul>
</div>
<h2><span class="mw-headline" id="Goals">Goals</span></h2>
<ul><li>Add the support for the GPU processing in ITK
<ul><li>GPU image class</li>
<li>Extension of ITK multithreading model to support the GPU</li>
<li>Pipeline supporting both CPU and GPU filters and images</li>
<li>Basic GPU image operators</li></ul></li></ul>
<h2><span class="mw-headline" id="Authors">Authors</span></h2>
<p>GPU acceleration for ITK v4 has been proposed by Harvard University and University of Utah (PI: Jim Miller from GE).
University of Pennsylvania is also participating for GPU image registration.
</p>
<ul><li>Won-Ki Jeong (wkjeong -at- seas.harvard.edu)</li>
<li>Baohua Wu (baohua -at- seas.upenn.edu)</li></ul>
<h2><span class="mw-headline" id="Summary">Summary</span></h2>
<ul><li>GPU image class that manages GPU and CPU data transparently from users</li>
<li>GPU image filter base class that supports pipelining</li>
<li>GPU data, context, kernel manager that help users to use OpenCL code easily with ITK</li>
<li>Object factory automatically creates images and filters for target architecture</li>
<li>GPU inPlace image filter</li>
<li>GPU Finite Difference Image Filter and Function classes</li></ul>
<h2><span class="mw-headline" id="Example_Filters">Example Filters</span></h2>
<ul><li>GPUMeanImageFilter</li>
<li>GPUBinaryThresholdImageFilter</li>
<li>GPUGradientAnisotropicDiffusionImageFilter</li>
<li>GPUDemonsRegistrationFilter</li></ul>
<h2><span class="mw-headline" id="New_Classes">New Classes</span></h2>
<h3><span class="mw-headline" id="GPUImage">GPUImage</span></h3>
<p>GPU image class.
</p>
<h3><span class="mw-headline" id="GPUDataManager">GPUDataManager</span></h3>
<p>Manage GPU data container and synchronize between the CPU and GPU. Used by GPU image class.
</p>
<h4><span class="mw-headline" id="GPUImageDataManager">GPUImageDataManager</span></h4>
<p>GPU data manager for GPUImage data, derived from GPUDataManager base class.
</p>
<h3><span class="mw-headline" id="GPUContextManager">GPUContextManager</span></h3>
<p>Manage GPU contexts and Command Queues.
</p>
<h3><span class="mw-headline" id="GPUKernelManager">GPUKernelManager</span></h3>
<p>Manage GPU programs and kernels, and execute kernels.
</p>
<h3><span class="mw-headline" id="GPUImageToImageFilter">GPUImageToImageFilter</span></h3>
<p>Base class for GPU-based ImageToImage filters. To write your own filter, derive a child class from this base class and implement GPUGenerateDate() accordingly.
</p>
<h4><span class="mw-headline" id="GPUMeanImageFilter">GPUMeanImageFilter</span></h4>
<p>Mean image filter implementation.
</p>
<h3><span class="mw-headline" id="GPUInPlaceImageFilter">GPUInPlaceImageFilter</span></h3>
<p>Base class for GPU-based inplace image filters. Input and output image is same. Graft() for GPU data is implemented.
</p>
<h4><span class="mw-headline" id="GPUBinaryThresholdImageFilter">GPUBinaryThresholdImageFilter</span></h4>
<p>Binary threshold image filter as an example of inplace image filter.
</p>
<h3><span class="mw-headline" id="GPUFiniteDifferenceImageFilter">GPUFiniteDifferenceImageFilter</span></h3>
<p>Base class for GPU-based finite difference image filters.
</p>
<h2><span class="mw-headline" id="Usage_Example">Usage Example</span></h2>
<p>ITK GPU classes hide low-level details to manage GPU resources and greatly reduce programmer's effort. You just need to create and modify GPU images as you would normally do for a regular ITK image (e.g., using pixel iterators, FillBuffer(), or SetPixel()). A GPU kernel can be created by as simple as using only three lines of code (creating kernel manager, loading source program, and creating kernel). After running a kernel on the GPU images, you can access pixel values using normal ITK pixel access APIs (e.g., GetPixel()). Synchronization between the CPU and GPU will be performed automatically and efficiently (lazy-evaluation), transparent to the users. Example:
</p>
<pre>typedef itk::GPUImage&lt;float, 2&gt; GPUImage1f;

//
// Create GPU images as normal itk image
//
GPUImage1f::Pointer srcA, srcB, dest;
srcA = GPUImage1f::New();
srcB = GPUImage1f::New();
dest = GPUImage1f::New();

//
// Initialize GPU images as you normally do for regular itk images
//
srcA-&gt;FillBuffer(1.0f);
srcB-&gt;FillBuffer(2.0f);
dest-&gt;FillBuffer(3.0f);

//
// Create GPU program object
//
GPUKernelManager::Pointer kernelManager = GPUKernelManager::New();

//
// Load OpenCL source code and compile
//
kernelManager-&gt;LoadProgramFromFile("ImageOps.cl");

//
// Create kernel
//
int kernel_add = kernelManager-&gt;CreateKernel("ImageAdd");

//
// Set parameters
//
unsigned int nElem = 65536;
kernelManager-&gt;SetKernelArgWithImage(kernel_add, 0, srcA-&gt;GetGPUDataManager());
kernelManager-&gt;SetKernelArgWithImage(kernel_add, 1, srcB-&gt;GetGPUDataManager());
kernelManager-&gt;SetKernelArgWithImage(kernel_add, 2, dest-&gt;GetGPUDataManager());
kernelManager-&gt;SetKernelArg(kernel_add, 3, sizeof(unsigned int), &amp;nElem);

//
// Launch Kernel
//
kernelManager-&gt;LaunchKernel2D(kernel_add, 16, 16, 16, 16);
</pre>
<h2><span class="mw-headline" id="Latest_Code">Latest Code</span></h2>
<ul><li>git@github.com:graphor/ITK.git (branch: GPU-Alpha)</li></ul>
<h2><span class="mw-headline" id="ToDo_List">ToDo List</span></h2>
<ul><li>GPUThreadedGenerateData() for multi-GPU support</li>
<li>Context/device management</li>
<li>InPlace GPU filter base class
<ul><li>Grafting for GPU data object</li></ul></li></ul>
<h2><span class="mw-headline" id="Plans">Plans</span></h2>
<h3><span class="mw-headline" id="GPU_image_class">GPU image class</span></h3>
<p>We propose a new GPU image class, itk::GPUImage,
which provides a GPU data container and functions for implicit and explicit data transfers
between the CPU and the GPU memory spaces. itk::GPUImage will contain two snapshots
of the current image—one on the CPU and one on the GPU—but provide the functionality of
a single image to the user. itk::GPUImage inherits all the public functions from itk::Image,
so it can be used with the existing CPU ITK image filters as before. All the pixel operators,
for example GetPixel(), and the image iterators can be used to modify pixel values on the
CPU side. Conversely, GPU code will modify the pixel values on the GPU side. We propose
an automatic synchronization mechanism between the CPU and GPU buffers, transparent to
the user. Specifically, we propose the following functionalities for the ITK GPU image class:
</p>
<ul><li>Efficient GPU memory management</li>
<li>CPU and GPU synchronization scheme</li>
<li>GPU buffer interface for direct access</li></ul>
<h3><span class="mw-headline" id="GPU_support_for_ITK_multithreading_model">GPU support for ITK multithreading model</span></h3>
<p>We will extend the ITK multithreaded architecture by introducing two new virtual functions, GPUGenerateData()
and GPUThreadedGenerateData(). These methods will borrow the implicit thread management
design from the existing architecture but manage threads based on GPU resources and
not CPU resources. When the filter is called, a superclass of the filter will decide between
single or multi-threaded execution and determine where to run the code, either on a CPU or
GPU. The superclass will spawn threads and call one of the four functions accordingly.
</p>
<h3><span class="mw-headline" id="Filter_API_to_support_GPU_code">Filter API to support GPU code</span></h3>
<p>We will implement a filter class that has an API to execute GPU code written in OpenCL.
</p>
<h3><span class="mw-headline" id="Basic_GPU_image_operators">Basic GPU image operators</span></h3>
<p>We propose a set of basic GPU image operators and filters that can be used as building blocks for more complicated numerical algorithms, such as:
</p>
<ul><li>Addition, subtraction, division, multiplication, inner product, reduction, copy and assignment operators</li>
<li>Neighborhood operator filter (for convolution-type filter)</li></ul>
<h3><span class="mw-headline" id="Wish_List_of_Classes_to_Support_GPU">Wish List of Classes to Support GPU</span></h3>
<ul><li><a class="mw-redirect" href="/Wiki/ITK_Release_4/GPU_Acceleration/Wish_List" title="ITK Release 4/GPU Acceleration/Wish List">Wish List of Filters to Support</a></li></ul>
<h2><span class="mw-headline" id="Target_architecture">Target architecture</span></h2>
<p>We are going to use OpenCL to implement GPU code for wide applicability (Intel, AMD, and NVIDIA). We will consider supporting NVIDIA CUDA as well if required (for example, to employ existing GPU libraries, such as CUFFT or CUBLAS).
</p><p>Architectures that have been confirmed to work as of ITK 4.2:
</p>
<table border="1">
<tbody><tr bgcolor="#abcdef">
<th>OS</th>
<th>GPU</th>
<th>Driver</th>
<th>OpenCL</th>
<th>Test Status
</th></tr>
<tr>
<td>Mac 10.6.8</td>
<td>NVIDIA GeForce GT 120 (9500 GT)</td>
<td>nvidia, included with OS</td>
<td>v 12.3.6, get info string 1.5.6</td>
<td>PASS
</td></tr>
<tr>
<td>Mac 10.7.?</td>
<td>NVIDIA GeForce 9400M and NVIDIA GeForce 9600M GT</td>
<td>included with OS</td>
<td>?</td>
<td>?
</td></tr>
<tr>
<td>Mac 10.7.3</td>
<td>ATI Radeon HD 5870</td>
<td>nvidia, included with OS</td>
<td>?</td>
<td>3D Mean Filter FAILS
</td></tr>
<tr>
<td>Mac 10.7.2</td>
<td>NVIDIA GeForce GT 120 (9500 GT)</td>
<td>nvidia, included with OS</td>
<td>v 1.50.63, get info string 1.50.63</td>
<td>PASS
</td></tr>
<tr>
<td>Linux OpenSUSE 11.4 (x86_64)</td>
<td>NVIDIA GeForce GTX 570</td>
<td>x86_64 280.13</td>
<td>NVIDIA GPU Computing SDK v?</td>
<td>PASS
</td></tr>
<tr>
<td>Linux OpenSUSE 11.4 (x86_64)</td>
<td>NVIDIA Tesla C2070</td>
<td>x86_64 280.13</td>
<td>NVIDIA GPU Computing SDK v?</td>
<td>PASS
</td></tr>
<tr>
<td>Linux OpenSUSE 12.1 (x86_64)</td>
<td>NVIDIA Quadro FX 5600</td>
<td>x86_64 295.33</td>
<td>nvidia Revision 10327</td>
<td>PASS
</td></tr>
<tr>
<td>Linux OpenSUSE 12.1 (x86_64)</td>
<td>NVIDIA GeForce GT120 (9500 GT)</td>
<td>x86_64 295.40-15.1</td>
<td>nvidia 295.40-15.1</td>
<td>PASS
</td></tr>
<tr>
<td>Linux OpenSUSE 12.1 (x86_64)</td>
<td>NVIDIA GeForce GT120 (9500 GT)</td>
<td>x86_64 295.40-15.1</td>
<td>intel 1.5 x64</td>
<td>PASS
</td></tr>
<tr>
<td>Windows 7 Professional SP1 (64-bit)</td>
<td>NVIDIA GeForce 8800 GTX</td>
<td>8.17.12.8562 (285.62)</td>
<td>NVIDIA GPU Computing SDK 4.0.19 Win 64</td>
<td>PASS
</td></tr>
<tr>
<td>Windows 7 Professional SP1 (64-bit)</td>
<td>NVIDIA GeForce 9500 GT (GT120)</td>
<td>8.17.12.9610</td>
<td>Intel SDK for ocl applications 2012 x64</td>
<td>PASS
</td></tr>
<tr>
<td>Windows 7 Professional SP1 (64-bit)</td>
<td>NVIDIA GeForce 9500 GT (GT120)</td>
<td>8.17.12.9610</td>
<td>NVIDIA GPU Computing SDK 4.2.9 Win 64</td>
<td>PASS
</td></tr>
<tr>
<td>Windows Vista Ultimate SP2 (64-bit)</td>
<td>ATI FireGL V7600</td>
<td>8.850.7.2000</td>
<td>AMD APP SDK v2.5 Windows 64 (AMD APP SDK Runtime 2.4.595.10)</td>
<td>Code compiles, all tests fail because GPU device not found.  According to <a class="external free" href="http://forums.amd.com/devforum/messageview.cfm?catid=390&amp;threadid=126463" rel="nofollow">http://forums.amd.com/devforum/messageview.cfm?catid=390&amp;threadid=126463</a>, this card is not supported
</td></tr></tbody></table>
<p><br/>
Potential error messages and fixes
</p>
<table border="1">
<tbody><tr bgcolor="#abcdef">
<th>Error</th>
<th>OS</th>
<th>Fix
</th></tr>
<tr>
<td>clGetPlatformIDs returns -1001 and 0 platforms</td>
<td>Linux</td>
<td>Make sure permissions for /dev/nvidia0 and /dev/nvidiactl are rw for your user
</td></tr>
<tr>
<td>error : Instruction ‘mov’ requires SM 1.3 or higher, or map_f64_to_f32 directive … ptxas fatal : Ptx assembly aborted due to errors … ptxas application ptx input, line 109; warning : Double is not supported. Demoting to float …</td>
<td>Any</td>
<td>Not all GPUs and/or drivers support double precision calculations.  Be sure to only instantiate floating point or integer filter types
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Instructions_for_Installing_OpenCL">Instructions for Installing OpenCL</span></h2>
<ul><li><a class="external free" href="http://www.khronos.org/opencl/" rel="nofollow">http://www.khronos.org/opencl/</a></li></ul>
<p>In specific platforms 
</p>
<ul><li><a class="external free" href="http://www.nvidia.com/object/cuda_opencl_new.html" rel="nofollow">http://www.nvidia.com/object/cuda_opencl_new.html</a></li>
<li><a class="external free" href="http://developer.amd.com/zones/OpenCLZone/pages/default.aspx" rel="nofollow">http://developer.amd.com/zones/OpenCLZone/pages/default.aspx</a></li>
<li><a class="external free" href="http://software.intel.com/en-us/articles/intel-opencl-sdk/" rel="nofollow">http://software.intel.com/en-us/articles/intel-opencl-sdk/</a></li></ul>
<h1><span class="mw-headline" id="Tcons">Tcons</span></h1>
<ul><li><a class="mw-redirect" href="/Wiki/ITK_Release_4/GPU_Acceleration/Tcon-2011-01-28" title="ITK Release 4/GPU Acceleration/Tcon-2011-01-28">Tcon 2011-01-28</a></li>
<li><a class="mw-redirect" href="/Wiki/ITK_Release_4/GPU_Acceleration/Tcon-2011-01-06" title="ITK Release 4/GPU Acceleration/Tcon-2011-01-06">Tcon 2011-01-06</a></li>
<li><a class="mw-redirect" href="/Wiki/ITK_Release_4/GPU_Acceleration/Tcon-2010-11-22" title="ITK Release 4/GPU Acceleration/Tcon-2010-11-22">Tcon 2010-11-22</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20240415200326
Cache expiry: 86400
Reduced expiry: false
Complications: []
CPU time usage: 0.015 seconds
Real time usage: 0.016 seconds
Preprocessor visited node count: 87/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 1143/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
<!-- Saved in parser cache with key KitwarePublicWikiDB:pcache:idhash:8227-0!canonical and timestamp 20240415200326 and revision id 49012. Serialized with JSON.
 -->
</div>
</div>

<!-- end content --></body>
</html>