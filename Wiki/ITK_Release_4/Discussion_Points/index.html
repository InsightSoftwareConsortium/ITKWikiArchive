<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>ITK Release 4/Discussion Points - KitwarePublic</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"0fd0ffd6cf90b41f7a7bc3ef","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"ITK_Release_4/Discussion_Points","wgTitle":"ITK Release 4/Discussion Points","wgCurRevisionId":31862,"wgRevisionId":31862,"wgArticleId":5603,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"ITK_Release_4/Discussion_Points","wgRelevantArticleId":5603,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]};RLSTATE={"site.styles":
"ready","user.styles":"ready","user":"ready","user.options":"loading","skins.monobook.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.monobook.scripts"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@1i9g4",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="/Wiki/load.php?lang=en&amp;modules=skins.monobook.styles&amp;only=styles&amp;skin=monobook"/>
<script async="" src="/Wiki/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=monobook"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="/Wiki/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=monobook"/>
<meta name="generator" content="MediaWiki 1.38.6"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0"/>
<link rel="shortcut icon" href="/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="/Wiki/opensearch_desc.php" title="KitwarePublic (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://public.kitware.com/Wiki/api.php?action=rsd"/>
<link rel="license" href="https://creativecommons.org/licenses/by/2.5/"/>
<link rel="alternate" type="application/atom+xml" title="KitwarePublic Atom feed" href="/Wiki/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-ITK_Release_4_Discussion_Points rootpage-ITK_Release_4 skin-monobook action-view skin--responsive"><!-- start content -->
				<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p><b>Discussion Points</b>
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Filenames_and_std::strings"><span class="tocnumber">1</span> <span class="toctext">Filenames and std::strings</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Threading_model_modifications"><span class="tocnumber">2</span> <span class="toctext">Threading model modifications</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Need_Explicit_Transition_Documentation"><span class="tocnumber">3</span> <span class="toctext">Need Explicit Transition Documentation</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Transforms"><span class="tocnumber">4</span> <span class="toctext">Transforms</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Image_Physical_Space/Domain"><span class="tocnumber">5</span> <span class="toctext">Image Physical Space/Domain</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Platform_support"><span class="tocnumber">6</span> <span class="toctext">Platform support</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#IO_interface_changes"><span class="tocnumber">7</span> <span class="toctext">IO interface changes</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Meta_Data_Dictionary"><span class="tocnumber">8</span> <span class="toctext">Meta Data Dictionary</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#ITK_Orientation"><span class="tocnumber">9</span> <span class="toctext">ITK Orientation</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#FFT"><span class="tocnumber">10</span> <span class="toctext">FFT</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#Numerics"><span class="tocnumber">11</span> <span class="toctext">Numerics</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Neural_Networks"><span class="tocnumber">12</span> <span class="toctext">Neural Networks</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Spatial_Objects"><span class="tocnumber">13</span> <span class="toctext">Spatial Objects</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Coding_style,_and_enforcement"><span class="tocnumber">14</span> <span class="toctext">Coding style, and enforcement</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Pipelines_and_Objects"><span class="tocnumber">15</span> <span class="toctext">Pipelines and Objects</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#Memory"><span class="tocnumber">16</span> <span class="toctext">Memory</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#Code_Clean-up"><span class="tocnumber">17</span> <span class="toctext">Code Clean-up</span></a></li>
<li class="toclevel-1 tocsection-18"><a href="#CMake_Flag_Clean-up"><span class="tocnumber">18</span> <span class="toctext">CMake Flag Clean-up</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Filenames_and_std::strings">Filenames and std::strings</span></h2>
<ul><li>Strings are std::strings:  Filenames should be std::strings, not const char* _arg
<ul><li>Set character string.  Creates member Set"name"() (e.g., SetFilename(char *)). The macro assumes that the class member (name) is declared a type std::string. */</li></ul></li></ul>
<h2><span class="mw-headline" id="Threading_model_modifications">Threading model modifications</span></h2>
<ol><li>Thread pools?</li>
<li>Hierarchal thread handlers?</li>
<li>Can threads deal with pushing data across hardware units with inconsistent memory models (i.e. 4 core SMP + GPU#1 + GPU#2)</li></ol>
<h2><span class="mw-headline" id="Need_Explicit_Transition_Documentation">Need Explicit Transition Documentation</span></h2>
<ol><li>To facilitate transition from ITK3 to ITK4, a set of migration documents and tools will be beneficial to researchers who will be migrating to their tools to ITK4.  As we adapt the reference applications to the changes occurring in ITK4, we will document the necessary source code changes to use the new version of ITK4.  When possible, we will write a set of scripting tools that transform ITK3 to ITK4, or identify old code that has become invalidated, and suggest alternative options.  We will deliver this documentation both as a standalone document and as an online WIKI-based web resource.</li></ol>
<h2><span class="mw-headline" id="Transforms">Transforms</span></h2>
<ol><li>Need ability to deal with concatenated physical space mappings (Rigid-»Affine-»BSpline-»Displacement-»Rigid-» etc)</li>
<li>Better protocols for reading/writing/ transforms including the ambiguous way that compound (i.e. not concatenated) transforms are represented.</li></ol>
<h2><span id="Image_Physical_Space.2FDomain"></span><span class="mw-headline" id="Image_Physical_Space/Domain">Image Physical Space/Domain</span></h2>
<ol><li>There is a need an image layer that does NOT have a physical space representation
<ol><li>ImageBase-»DigitalImage-»ContinuousImage-»[Image(the current interpretation)|GeoSpatialImage|Other physical space]</li>
<li>Most PixelWise filters will be defined over the DigitalImage layer to explicitly identify them as not dealing with physical space</li>
<li>Digital to Continuous conversion API is consistent (TransformIndexToPhysical &amp; PhysicalToIndexTransform), but may be adaptable to address the needs of our expanding user base</li>
<li>The current "Image" designator is explicitly defined as an (LPS anatomical, East|North|Altitude) with Direction cosigns, spacing, origin and appropriate</li>
<li>Units:  A designation that can hint to the application level how to interpret physical space.  Perhaps the filters would just verify that units are the same.  (default being non-existing and therefore the same).</li></ol></li></ol>
<h2><span class="mw-headline" id="Platform_support">Platform support</span></h2>
<ul><li>a platform is a [Hardware, OS, Compiler, Compiler options]</li></ul>
<ol><li>Reduce build burden -- Explicit Templates &amp; Pre-compiled headers:
<ol><li>Under the assumption that the scope of the simple &amp; wrapping frameworks will define a large swath of instantiations that almost all applications also need.   By defining and pre-compling those common (perhaps driven by the wrapping choices) tools, compiling the application layers will be significantly faster.   This should reduce the burden on application developers by shifting build time costs away form the time of building the applications.</li>
<li>We do have to be careful to limit this (or provide options to limit this) so that the default build does not take 10 hours.</li>
<li>This does imply that the compiler MUST support explicit instantiation of templates</li>
<li>---- As a side note, perhaps we also need to investigate pre-compiled header support for compilers to lower the development burden</li></ol></li>
<li>An explicit deprecation cycle for ALL compilers
<ol><li>It is CRUCIAL that we define upfront a MINIMUM time frame for how long each version of ITK4 we commit to supporting all platforms.  It is expected that these dates will shift into the future, but not earlier.
<ol><li>Windows 7, Visual Studio 2010 will be supported at least until Jan 1, 2017</li>
<li>Windows XP, Visual Studio Express 8 will be supported at least until Jan 1, 2015</li>
<li>Linux gcc version 4 (greater than 4.0.1) will be supported at least until Jan 1, 2012</li></ol></li></ol></li>
<li>Compilers need to be compliant with the C++03 standards. <a rel="nofollow" class="external free" href="http://en.wikipedia.org/wiki/C%2B%2B">http://en.wikipedia.org/wiki/C%2B%2B</a></li></ol>
<h2><span class="mw-headline" id="IO_interface_changes">IO interface changes</span></h2>
<ol><li>Transforms components "Can be written", but there is insufficient information to un-ambiguously derive the intent and appropriate use of those transform parameters.  In particular, the parameters for BSpline are written to disk in two components, and the BSpline parameters are linearly written, but the implied grid for those parameters is not specified in the output file. As a use case, the BSpline transform type SHOULD be able to be instantiated from just the information in the file.</li>
<li>Are there IO factory simplifications that could be done? i.e. remove separatedFactories for each type</li></ol>
<h2><span class="mw-headline" id="Meta_Data_Dictionary">Meta Data Dictionary</span></h2>
<ol><li>MetaData Dictionary items need "Traits"  to help identify the "social status" of the element (such as ITK_SUPPORTED_PUBLIC, ITK_SUPPORTED_PRIVATE, UNSUPPORTED_PRIVATE, UNSUPPORTED_PUBLIC).</li>
<li>The first contribution of the Iowa ITK development team was to introduce the “MetaDataDictionary” storage mechanism to all ITK Objects that could contain arbitrary key-value pairs of data.  The MetaDataDictionary was not part of the original ITK framework definition, and has therefore not been consistently implemented throughout the ITK toolkit.  We propose to revisit the implementation of the MetaDataDictionary to improve and simplify the ABI so that it is easier to use.  In particular, the Encapsulate() and Expose() functions can now be simplified when using standards-compliant C++ compilers, and new features for describing a dynamically created dictionary at run time will be introduced. A common use of the MetaDataDictionary has been to temporally append features that were missing in the initial ITK framework.  In many cases, the use of the MetaDataDictionary was subsequently followed by addition of formal support of the feature to ITK, and this lead to redundancy of information that was not always kept synchronized.  Additionally, as new developers adopted the MetaDataDictionary for different uses, they each created inconsistent definitions for similar uses of the dictionary.  We will review the internal ITK uses of the MetaDataDictionary, remove uses that are now redundant with formal accepted functionality, and consolidate similar uses of the Dictionary. The MetaDataDictionary is most commonly used to pass additional information to or from the Input/Output mechanisms.  We will define a protocol so that data object histories can be tracked through consistent instrumentation of ITK process objects to tag output objects.  We will review the Input/Output and develop a standard practices guideline for how to map the extra data to and from ITK in a consistent way. Wherever possible, we will use tags and definitions consistent with the dictionaries specified in the DICOM standard.</li></ol>
<h2><span class="mw-headline" id="ITK_Orientation">ITK Orientation</span></h2>
<ol><li>Instrument the itk::ImageIO methods to record spatial image orientation in the MetaDataDictionary prior to it’s inclusion as a formal feature.  This solution allowed representation of which of 48 possible 3D orientations the image was in.  This was represented symbolically by 3 letter combinations, based on permuting (A)nterior/(Posterier), (I)nferior/(S)uperior, (L)eft/(R)ight. For example RAS meant that the voxels are oriented Right-to-Left, Anterior-to-Posterior, Superior to Inferior, corresponding to Row/Column/Slice. This method of specifying orientation is useful but very limited; many anatomical scanners allow scanning at oblique angles with respect to anatomy.  So after long discussion in the ITK developer community, a more general method was developed, which represented the orientation as a direction cosine matrix (DCM). The direction cosines specify a general 3D rotation of the image voxels with respect to the anatomy being scanned. The long experience with brain imaging research at Iowa will inform our implementation of these changes.  However, we also recognize and highly value the expertise of the other members of the ITK developer community, and the implementation will be guided by the consensus judgment of the community as a whole. We will enhance the code infrastructure of ITK with respect to issues of position and orientation of images.  Deliverables will comprise both changes to the core ITK library code, and extensive regression tests to verify correct operation with the rest of the ITK Library. There are three ways in which the handling of orientation in ITK needs to be improved:</li>
<li>Currently the size of the direction cosines is linked to the number of dimensions in the image – for a 2D Image, they comprise a 2x2 DCM, for a 3D Image 3x3, etc.  Conceptually, the use of the current orientation description is most suited for describing images with exactly 3 spatial dimensions.   We believe this needs to be changed and generalized to accommodate describing data sets within a higher dimensional space, or with respect measurement direction that is different from scanning direction.  First, any 2D scan of anatomy will have an implied third axes, parallel to the direction of image acquisition.  In particular, 2D DICOM slice images always report the three-dimensional image position of the scan with respect to the patient.  At present, when ITK reads a single 2D DICOM image, there is no way to preserve it’s relationship to 3D-space.  Finally, the orientation of a measurement frame with respect to sub-volumes is necessary to properly represent complex acquisition types (such as diffusion weighted imaging). Similarly, 2D Images can have a three-dimensional image origin with a well-defined anatomical meaning.  Discarding that when reading the image is a loss of information.  In both cases (orientation and origin) it will be necessary to enforce backwards compatibility.  This will be achieved in two ways: by adding new class methods that are explicitly three-dimensional, and by careful testing of all ITK classes to ensure their continued correct operation.</li></ol>
<h2><span class="mw-headline" id="FFT">FFT</span></h2>
<ul><li>Need more FFT adaptors, and a slight refactoring of FFT adaptor base to meet several platform</li></ul>
<ol><li>It would be nice to have a compliant FFT built in with reasonable performance (vnl does not work)</li>
<li>Mac Accelerate framework, Intel MLK,</li></ol>
<h2><span class="mw-headline" id="Numerics">Numerics</span></h2>
<ul><li>Need adaptors for some subsets of (SVD/LAPACK/BLAS) numerics:</li></ul>
<ol><li>Should be able to take advantage of the Mac Acclerate, Intel MLK, Atlas or others with minimal end user configuration</li></ol>
<h2><span class="mw-headline" id="Neural_Networks">Neural Networks</span></h2>
<ul><li>Remove NeuralNetwork</li></ul>
<ol><li>The current implementation in ITK requires that the network architecture and Input/Output routines be completely defined at compile-time.  This severely limits the utility of the current implementation.   The Input/Output mechanism of the current Neural Network currently only supports a proprietary network file format.  This limits the ability to analyze the networks with complex external tools such as Matlab Neural Network toolkit.</li></ol>
<ul><li>Consider linking with FANN</li></ul>
<h2><span class="mw-headline" id="Spatial_Objects">Spatial Objects</span></h2>
<ul><li>Use cases
<ol><li>Load, save, and manipulate segmentation results (multiple objects) produced by different methods
<ul><li>multiple objects = labelmaps, parametric object representations, etc in a common coordinate/reference system</li>
<li>different methods = segmentation, registration, simulation</li>
<li>manipulate = register, send to visualization package, use as a mask for subsequent processing</li></ul></li>
<li>Load, save, and manipulate multiple instances of the same object from multiple people
<ul><li>e.g., use a collection of objects to conduct a population-based study</li></ul></li>
<li>Load, save, and manipulate multiple objects over time and space</li>
<li>Represent objects in a hierarchy
<ul><li>tree of tubes, liver contains vessels, ...</li>
<li>perhaps different views of the same collection of objects should be possible (e.g., all vessels -vs- liver's vessels)</li></ul></li></ol></li>
<li>Changes needed
<ul><li>Support ND Objects</li>
<li>Clean API to remove secondary/obscure effects (e.g., tree depth of -1 means the entire tree)</li>
<li>Support time</li></ul></li>
<li>Wish-list
<ul><li>Have parametric objects that can be fit using itk optimizers</li>
<li>Consider 3rd-party compatibility (wrapping or data exchange)</li></ul></li>
<li>Notes
<ul><li>Consider lessons learned from 3rd-party solutions (strengths and weaknesses)</li>
<li>Related 3rd-party solutions</li>
<li>MRML</li>
<li>ghost (haptics scene graph from Phantom)</li>
<li>OpenInventor</li>
<li>OpenCV (?)</li>
<li>SOFA</li>
<li>VTK (?)</li>
<li>SOViewers</li></ul></li>
<li><a href="/Wiki/ITK_Release_4/SpatialObjects" class="mw-redirect" title="ITK Release 4/SpatialObjects"> Spatial Object Refactoring project page</a></li></ul>
<h2><span id="Coding_style.2C_and_enforcement"></span><span class="mw-headline" id="Coding_style,_and_enforcement">Coding style, and enforcement</span></h2>
<ol><li>There should be some system somewhere that is compliant with the ITK coding style.  It would be preferable if the primary development editors (VS, vim, emacs) could all be configured to support the style consistently.</li>
<li>The uncrustify program MAY allow a conduit for helping new developers format to be KWSTYLE compliant.</li></ol>
<h2><span class="mw-headline" id="Pipelines_and_Objects">Pipelines and Objects</span></h2>
<ul><li>All process object outputs should be available as data objects (including native types)</li></ul>
<ol><li>There are times when a filter computes a value that is used as input into later stages of the pipeline,  there needs to be  a way to easily link filters and have the pipeline work properly even when the linkage is a simple integer.</li></ol>
<h2><span class="mw-headline" id="Memory">Memory</span></h2>
<ul><li>Should the default behavior of all filters be to release their input data</li></ul>
<ol><li>This may address the complaint that ITK has unacceptable memory usage.</li></ol>
<h2><span class="mw-headline" id="Code_Clean-up">Code Clean-up</span></h2>
<ul><li>All class objects that end in "2" as a mechanism to fix bugs, and not break backwards compatibility should be removed.</li>
<li>itk_hashtable.h should be investigated to determine if a more standard implementation could replace the existing version.  The current version has many different implementations for dealing with different compiler bases.</li></ul>
<h2><span class="mw-headline" id="CMake_Flag_Clean-up">CMake Flag Clean-up</span></h2>
<ol><li>Need to review the ITK_LEAN_AND_MEAN flags
<ul><li>Should this be controled by a CMakeFlag?  It used to be bound to the BORLAND compiler defintions, but since that is now gone, it's use is less clear.</li>
<li>What is the intended purpose?</li>
<li>Can this be formalized better?</li></ul></li></ol>
<!-- 
NewPP limit report
Cached time: 20250112190251
Cache expiry: 86400
Reduced expiry: false
Complications: []
CPU time usage: 0.010 seconds
Real time usage: 0.011 seconds
Preprocessor visited node count: 55/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key KitwarePublicWikiDB:pcache:idhash:5603-0!canonical and timestamp 20250112190251 and revision id 31862. Serialized with JSON.
 -->
</div>
<div class="printfooter">Retrieved from "<a dir="ltr" href="https://public.kitware.com/Wiki/index.php?title=ITK_Release_4/Discussion_Points&amp;oldid=31862">https://public.kitware.com/Wiki/index.php?title=ITK_Release_4/Discussion_Points&amp;oldid=31862</a>"</div></div>
				<div id="catlinks" class="catlinks catlinks-allhidden" data-mw="interface"></div>
				<!-- end content --></body>
</html>