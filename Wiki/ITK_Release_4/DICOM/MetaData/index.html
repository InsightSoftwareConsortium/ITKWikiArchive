<!DOCTYPE html>

<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="utf-8"/>
<title>ITK/Release 4/DICOM/MetaData</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":!1,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"bd86f30025fed54cfe8362f0","wgCSPNonce":!1,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":!1,"wgNamespaceNumber":0,"wgPageName":"ITK/Release_4/DICOM/MetaData","wgTitle":"ITK/Release 4/DICOM/MetaData","wgCurRevisionId":44279,"wgRevisionId":44279,"wgArticleId":8037,"wgIsArticle":!0,"wgIsRedirect":!1,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"ITK/Release_4/DICOM/MetaData","wgRelevantArticleId":8037,"wgIsProbablyEditable":!1,"wgRelevantPageIsProbablyEditable":!1,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRedirectedFrom":
"ITK_Release_4/DICOM/MetaData","wgInternalRedirectTargetUrl":"/ITKWikiArchive/Wiki/ITK/Release_4/DICOM/MetaData"};RLSTATE={"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"loading","skins.monobook.styles":"ready"};RLPAGEMODULES=["mediawiki.action.view.redirect","site","mediawiki.page.ready","skins.monobook.scripts"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@1hzgi",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});});</script>
<link href="/Wiki/load.php?lang=en&amp;modules=skins.monobook.styles&amp;only=styles&amp;skin=monobook" rel="stylesheet"/>
<script async="" src="/Wiki/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=monobook"></script>
<meta content="" name="ResourceLoaderDynamicStyles"/>
<link href="/Wiki/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=monobook" rel="stylesheet"/>
<meta content="MediaWiki 1.37.1" name="generator"/>
<meta content="telephone=no" name="format-detection"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0" name="viewport"/>
<link href="/favicon.ico" rel="shortcut icon"/>
<link href="/Wiki/opensearch_desc.php" rel="search" title="KitwarePublic (en)" type="application/opensearchdescription+xml"/>
<link href="https://public.kitware.com/Wiki/api.php?action=rsd" rel="EditURI" type="application/rsd+xml"/>
<link href="https://creativecommons.org/licenses/by/2.5/" rel="license"/>
<link href="/Wiki/index.php?title=Special:RecentChanges&amp;feed=atom" rel="alternate" title="KitwarePublic Atom feed" type="application/atom+xml"/>
<link href="https://public.kitware.com/ITKWikiArchive/Wiki/ITK/Release_4/DICOM/MetaData" rel="canonical"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-ITK_Release_4_DICOM_MetaData rootpage-ITK skin-monobook action-view skin--responsive"><!-- start content -->
<div class="mw-body-content mw-content-ltr" dir="ltr" id="mw-content-text" lang="en"><div class="mw-parser-output"><h2><span class="mw-headline" id="Question">Question</span></h2>
<p>How can ITK handle DICOM dataset within its framework. By design DICOM carries much more than just the Pixel Data, special handling need to be added to the DICOM ImageIO to handle this DICOM dataset (containing Patient information, protocol acuiqisiton parameters).
</p>
<h2><span class="mw-headline" id="Current_Solution">Current Solution</span></h2>
<p>It uses the MetaDataDictionary to store all the meta information. Currently :
</p>
<ul><li>ASCII based information is passed as is</li>
<li>Binary based information is converted using mime64 encoding</li></ul>
<p>This implementation currently suffers:
</p>
<ul><li>slow down reading pipeline</li>
<li>need to reimplement MetaData filters at ITK (duplicate effort from DICOM toolkit)</li></ul>
<h2><span class="mw-headline" id="Proposed_Solution">Proposed Solution</span></h2>
<p>Have a itk::DICOMDataSet interface which has concrete sublclass (dcmtk or gdcm). So that filter for metadata can be quickly constructed using third party libary.
</p><p>This process:
</p>
<ul><li>greatly speed up reading as no copying or converting of information (no potential loss) occur</li>
<li>this reduce code duplication</li></ul>
<p>Current implementation available at:
</p>
<ul><li><a class="external free" href="https://github.com/malaterre/ITKDICOM/blob/master/itkDICOMDataSet.h" rel="nofollow">https://github.com/malaterre/ITKDICOM/blob/master/itkDICOMDataSet.h</a></li>
<li><a class="external free" href="https://github.com/malaterre/ITKDICOM/blob/master/itkDICOMDataSet.cxx" rel="nofollow">https://github.com/malaterre/ITKDICOM/blob/master/itkDICOMDataSet.cxx</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20221202231132
Cache expiry: 86400
Reduced expiry: false
Complications: []
CPU time usage: 0.004 seconds
Real time usage: 0.004 seconds
Preprocessor visited node count: 8/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
<!-- Saved in parser cache with key KitwarePublicWikiDB:pcache:idhash:8037-0!canonical and timestamp 20221202231132 and revision id 44279. Serialized with JSON.
 -->
</div>
</div>

<!-- end content --></body></html>