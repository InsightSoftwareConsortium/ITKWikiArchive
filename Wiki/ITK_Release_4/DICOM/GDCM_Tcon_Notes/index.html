<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>ITK/Release 4/DICOM/GDCM Tcon Notes - KitwarePublic</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":!1,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"ddd9a92a4a8f591ae9e11aee","wgCSPNonce":!1,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":!1,"wgNamespaceNumber":0,"wgPageName":"ITK/Release_4/DICOM/GDCM_Tcon_Notes","wgTitle":"ITK/Release 4/DICOM/GDCM Tcon Notes","wgCurRevisionId":44273,"wgRevisionId":44273,"wgArticleId":9071,"wgIsArticle":!0,"wgIsRedirect":!1,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"ITK/Release_4/DICOM/GDCM_Tcon_Notes","wgRelevantArticleId":9071,"wgIsProbablyEditable":!1,"wgRelevantPageIsProbablyEditable":!1,"wgRestrictionEdit":[],"wgRestrictionMove":[],
"wgRedirectedFrom":"ITK_Release_4/DICOM/GDCM_Tcon_Notes","wgInternalRedirectTargetUrl":"/ITKWikiArchive/Wiki/ITK/Release_4/DICOM/GDCM_Tcon_Notes"};RLSTATE={"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"loading","skins.monobook.styles":"ready"};RLPAGEMODULES=["mediawiki.action.view.redirect","site","mediawiki.page.ready","mediawiki.toc","skins.monobook.scripts"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@1hzgi",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});});</script>
<link rel="stylesheet" href="/Wiki/load.php?lang=en&amp;modules=skins.monobook.styles&amp;only=styles&amp;skin=monobook"/>
<script async="" src="/Wiki/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=monobook"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="/Wiki/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=monobook"/>
<meta name="generator" content="MediaWiki 1.37.1"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0"/>
<link rel="shortcut icon" href="/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="/Wiki/opensearch_desc.php" title="KitwarePublic (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://public.kitware.com/Wiki/api.php?action=rsd"/>
<link rel="license" href="https://creativecommons.org/licenses/by/2.5/"/>
<link rel="alternate" type="application/atom+xml" title="KitwarePublic Atom feed" href="/Wiki/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<link rel="canonical" href="https://public.kitware.com/ITKWikiArchive/Wiki/ITK/Release_4/DICOM/GDCM_Tcon_Notes"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-ITK_Release_4_DICOM_GDCM_Tcon_Notes rootpage-ITK skin-monobook action-view skin--responsive"><!-- start content -->
				<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>Luis Ibanez, Andrew Wasem and Mark Roden were in attendance of this meeting.
The meeting was on the current and future progress of GDCM/ITK. 
</p><p><br />
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Example_of_how_to_run_an_RT-STRUCT_in_VTK"><span class="tocnumber">1</span> <span class="toctext">Example of how to run an RT-STRUCT in VTK</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Streaming_of_DIcom_images_(from_PACS)"><span class="tocnumber">2</span> <span class="toctext">Streaming of DIcom images (from PACS)</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Failing_streaming_test"><span class="tocnumber">2.1</span> <span class="toctext">Failing streaming test</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Another_streaming_issue"><span class="tocnumber">2.2</span> <span class="toctext">Another streaming issue</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#StreamImageReader"><span class="tocnumber">2.2.1</span> <span class="toctext">StreamImageReader</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#The_class:_OffsetTable"><span class="tocnumber">2.2.2</span> <span class="toctext">The class: OffsetTable</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#manages_byte_swapping"><span class="tocnumber">2.2.3</span> <span class="toctext">manages byte swapping</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-8"><a href="#DICOM_files_withJPEG"><span class="tocnumber">2.3</span> <span class="toctext">DICOM files withJPEG</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#DICOM_Slices"><span class="tocnumber">2.4</span> <span class="toctext">DICOM Slices</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#GDCM_StreamingWriting"><span class="tocnumber">2.5</span> <span class="toctext">GDCM  StreamingWriting</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#StreamReader_in_GDCM"><span class="tocnumber">2.6</span> <span class="toctext">StreamReader in GDCM</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-12"><a href="#PACS_-_DICOM_Protocol_-_Networking"><span class="tocnumber">3</span> <span class="toctext">PACS - DICOM Protocol - Networking</span></a>
<ul>
<li class="toclevel-2 tocsection-13"><a href="#Networking"><span class="tocnumber">3.1</span> <span class="toctext">Networking</span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Example_of_how_to_run_an_RT-STRUCT_in_VTK">Example of how to run an RT-STRUCT in VTK</span></h1>
<ul><li>src/gdcm/Utilities/VTK/Examples/Cxx/GenerateRTSTRUCT.cxx</li>
<li>src/gdcm/Utilities/VTK/vtkGDCMPolyDataWriter.h</li></ul>
<pre> void vtkGDCMPolyDataWriter::InitializeRTStructSet(vtkStdString inDirectory,
                                                vtkStdString inStructLabel,
                                                vtkStdString inStructName,
                                                vtkStringArray* inROINames,
                                                vtkStringArray* inROIAlgorithmName,
                                                vtkStringArray* inROIType)
</pre>
<h1><span id="Streaming_of_DIcom_images_.28from_PACS.29"></span><span class="mw-headline" id="Streaming_of_DIcom_images_(from_PACS)">Streaming of DIcom images (from PACS)</span></h1>
<h2><span class="mw-headline" id="Failing_streaming_test">Failing streaming test</span></h2>
<p>is using a malformed DICOM image. must change the input image. replace it with one of the brainsets from the Osirix collection of public data. Cerebrix. (apparently this is failing only in an icc build)
</p>
<h2><span class="mw-headline" id="Another_streaming_issue">Another streaming issue</span></h2>
<h3><span class="mw-headline" id="StreamImageReader">StreamImageReader</span></h3>
<ul><li>ITK/Modules/ThirdParty/GDCM/src/gdcm/Source/MediaStorageAndFileFormat</li></ul>
<pre> gdcmStreamImageReader.h
 gdcmStreamImageReader.cxx
 Limited to uint16:
 mXMin = mYMin = mZMin = std::numeric_limits&lt;uint16_t&gt;::max();
 mXMax = mYMax = mZMax = std::numeric_limits&lt;uint16_t&gt;::min();
</pre>
<p>then
</p>
<pre> uint32_t StreamImageReader::DefineProperBufferLength() const is limited uint32_t, in number of bytes.
</pre>
<p>Then read the actual buffer:
</p>
<pre>  bool StreamImageReader::Read(void* inReadBuffer, const std::size_t&amp; inBufferLength)

</pre>
<p>(before we call ReadImageInformation)
</p>
<h3><span class="mw-headline" id="The_class:_OffsetTable">The class: OffsetTable</span></h3>
<ul><li>ITK/Modules/ThirdParty/GDCM/src/gdcm/Source/DataStructureAndEncodingDefinition</li></ul>
<pre> gdcmBasicOffsetTable.h
</pre>
<p>defines sections (regions) of the image that have been compressed.
The reading code is implemented for RAW files that do not have an offset table.
This could be used to extend GDCM to not have to read a full plane, 
but instead read a subregion of that plane, and  therefore be more
compatible with ITK streaming.
</p>
<pre> bool StreamImageReader::ReadImageSubregionJpegLS(char* inReadBuffer, const std::size_t&amp; inBufferLength)
</pre>
<p>This function is used (or was intended for...)  to read
metadata without reading the pixel data yet.
</p>
<h3><span class="mw-headline" id="manages_byte_swapping">manages byte swapping</span></h3>
<pre> bool needbyteswap = (ts == TransferSyntax::ImplicitVRBigEndianPrivateGE);
</pre>
<p>line 244:
</p>
<pre>  theCodec.Decode(de, inReadBuffer, inBufferLength, mXMin, mXMax, mYMin, mYMax, mZMin, mZMax);
</pre>
<p>do the decoding by delegates to the JpegLS library.
</p>
<h2><span class="mw-headline" id="DICOM_files_withJPEG">DICOM files withJPEG</span></h2>
<p>We only have been able to find DICOM files withJPEG,
that have a single tile.
</p><p>(it will be nice to get some with multiple tile).
</p>
<h2><span class="mw-headline" id="DICOM_Slices">DICOM Slices</span></h2>
<p>It is also possible to find DICOM Slices that are composed
of a group of individual JPEG images.  (e.g. like doing tiling
by hand).
</p>
<hr />
<p><br />
</p>
<pre>Tag thePixelDataTag(0x7fe0, 0x0010);//must be LESS than the pixel
</pre>
<p>information tag, 0x7fe0,0x0010
</p><p>This is the location where the pixel data buffer.
</p><p>but in some cases, some images have more tags after this one,
and that can confuse the stream reading.
</p><p><br />
</p>
<h2><span class="mw-headline" id="GDCM_StreamingWriting">GDCM  StreamingWriting</span></h2>
<p>The GDCM  StreamingWriting is not working at this point.
</p><p>(something deep inside of gdcm).
</p><p><br />
--
</p><p>gdcmStreamImageWriter.cxx &#160;: 346
</p><p>bool StreamImageWriter::CanWriteFile() const
</p>
<pre>bool hasTag818 = mFile.GetDataSet().FindDataElement(Tag(0x08,0x18));
if (!hasTag23 &amp;&amp; !hasTag818){
</pre>
<p>When writing a DICOM image, the Tag818 must
be different from the one that it was read from.
(unless you are an OEM... e.g. the manufacturer
of a CT scanner.)
</p><p><br />
Then, when it gets to
</p><p>bool StreamImageWriter::WriteImageInformation(){
</p><p>it fails..
</p><p>Line 110 describe how to read the tags.
</p><p>Reading is done in 116.
</p><p><br />
The problem relates to the offset table...
</p><p>and how it addresses space inside of the image.
</p><p>This is mostly a problem when data is compressed.
(streaming raw data will be easier, but it is not
working now either...the output file is not readable.).
</p><p>(its MD5 sum for the pixel buffer doesn't match after writing...)
</p><p><br />
</p>
<h2><span class="mw-headline" id="StreamReader_in_GDCM">StreamReader in GDCM</span></h2>
<p>The StreamReader in GDCM is intended to be used
by the ITK streaming reader.
</p><p>(apparently the StreamReader is not used outside of ITK).
</p><p>There is a passing test for stream reading.
</p>
<h1><span class="mw-headline" id="PACS_-_DICOM_Protocol_-_Networking">PACS - DICOM Protocol - Networking</span></h1>
<h2><span class="mw-headline" id="Networking">Networking</span></h2>
<p>ITK/Modules/ThirdParty/GDCM/src/gdcm/Source/MessageExchangeDefinition/
</p><p>gdcmCompositeNetworkFunctions.cxx
</p>
<pre>static bool CEcho( const char *remote, uint16_t portno, const char
</pre>
<ul><li>aetitle = NULL,</li></ul>
<pre>  const char *call = NULL );
</pre>
<p>A server will have "titles" (up to 8).
</p><p>A title is a "computer name", not an IP address.
Every title connects to a specific port in the server
</p><p>CEcho is the basic test function
</p><p><br />
</p><p>Then you construct your query:
</p>
<pre>/// This function will take a list of strings and tags and fill in a
</pre>
<p>query that
</p>
<pre>/// can be used for either CFind or CMove (depending on the input boolean
/// \param inMove).
/// Note that the caller is responsible for deleting the constructed query.
/// This function is used to build both a move and a find query
/// (true for inMove if it's move, false if it's find)
static BaseRootQuery* ConstructQuery(ERootType inRootType,
</pre>
<p>EQueryLevel inQueryLevel,
</p>
<pre>  const DataSet&amp; queryds, bool inMove = false );
</pre>
<pre>/// \deprecated
static BaseRootQuery* ConstructQuery(ERootType inRootType,
</pre>
<p>EQueryLevel inQueryLevel,
</p>
<pre>  const KeyValuePairArrayType&amp; keys, bool inMove = false );
</pre>
<p><br />
(it requires a fully form dataset).
</p><p><br />
BaseRootQuery = abstract class
</p><p>2 types of queries&#160;: find &amp; move
</p><p>"find" can be using a very generic expression.
(can have wildcards).
</p><p>ITK/Modules/ThirdParty/GDCM/src/gdcm/Source/MessageExchangeDefinition
</p><p>gdcmFindPatientRootQuery.h
</p><p><br />
First figure out what tags are available:
</p>
<pre>std::vector&lt;Tag&gt; GetTagListByLevel(const EQueryLevel&amp; inQueryLevel);
</pre>
<p><br />
this ties up to the "image interpretation layer" to the point where
a juser can get this list of Tags and then select values from them
to put them in a query and using to get actual data.
</p><p><br />
"move" queries are more strict than "find" ones
(can't have wildcards).
</p><p>This search will fail if it is not fully specified.
</p>
<hr />
<p>gdcmCompositeNetworkFunctions.cxx
</p><p>bool CompositeNetworkFunctions::CStore( const char *remote, uint16_t portno,
</p>
<pre>const Directory::FilenamesType&amp; filenames,
const char *aetitle, const char *call)
</pre>
<p>267
</p><p>CStore command will move images to a server.
</p>
<hr />
<p>gdcmServiceClassUser.h
</p>
<pre>bool SendMove(const BaseRootQuery* query, const char *outputdir);
bool SendMove(const BaseRootQuery* query, std::vector&lt;DataSet&gt; &amp;retDatasets);
</pre>
<p>allows to put data directly into memory.
</p><p>(pending a refactoring in which the concept of
</p>
<pre>a DICOM file was planned to be abstracted...)
</pre>
<hr />
<p>ITK application, creating an itk::Image using data
from a remote server.
</p><p>(list of use cases in another email from Mark...)
</p><p><br />
In order to define ITK functionalities, we
should specify a list of clear use cases....
</p><p><br />
(Review emails from DICOM Taskforce February 23-24)
(post the use cases in a Wiki page).
</p>
<!-- 
NewPP limit report
Cached time: 20221004095506
Cache expiry: 86400
Reduced expiry: false
Complications: []
CPU time usage: 0.013 seconds
Real time usage: 0.014 seconds
Preprocessor visited node count: 39/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key KitwarePublicWikiDB:pcache:idhash:9071-0!canonical and timestamp 20221004095506 and revision id 44273. Serialized with JSON.
 -->
</div>
<div class="printfooter">Retrieved from "<a dir="ltr" href="https://public.kitware.com/Wiki/index.php?title=ITK/Release_4/DICOM/GDCM_Tcon_Notes&amp;oldid=44273">https://public.kitware.com/Wiki/index.php?title=ITK/Release_4/DICOM/GDCM_Tcon_Notes&amp;oldid=44273</a>"</div></div>
				<div id="catlinks" class="catlinks catlinks-allhidden" data-mw="interface"></div>
				<!-- end content --></body></html>