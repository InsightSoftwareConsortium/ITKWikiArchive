<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>ITK/Release 4/UnitTesting</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":!1,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"b076b962d9ad73ffa07bb2a2","wgCSPNonce":!1,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":!1,"wgNamespaceNumber":0,"wgPageName":"ITK/Release_4/UnitTesting","wgTitle":"ITK/Release 4/UnitTesting","wgCurRevisionId":44207,"wgRevisionId":44207,"wgArticleId":6705,"wgIsArticle":!0,"wgIsRedirect":!1,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"ITK/Release_4/UnitTesting","wgRelevantArticleId":6705,"wgIsProbablyEditable":!1,"wgRelevantPageIsProbablyEditable":!1,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRedirectedFrom":
"ITK_Release_4/UnitTesting","wgInternalRedirectTargetUrl":"/ITKWikiArchive/Wiki/ITK/Release_4/UnitTesting"};RLSTATE={"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"loading","skins.monobook.styles":"ready"};RLPAGEMODULES=["mediawiki.action.view.redirect","site","mediawiki.page.ready","mediawiki.toc","skins.monobook.scripts"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@1hzgi",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});});</script>
<link rel="stylesheet" href="/Wiki/load.php?lang=en&amp;modules=skins.monobook.styles&amp;only=styles&amp;skin=monobook"/>
<script async="" src="/Wiki/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=monobook"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="/Wiki/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=monobook"/>
<meta name="generator" content="MediaWiki 1.37.1"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0"/>
<link rel="shortcut icon" href="/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="/Wiki/opensearch_desc.php" title="KitwarePublic (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://public.kitware.com/Wiki/api.php?action=rsd"/>
<link rel="license" href="https://creativecommons.org/licenses/by/2.5/"/>
<link rel="alternate" type="application/atom+xml" title="KitwarePublic Atom feed" href="/Wiki/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<link rel="canonical" href="https://public.kitware.com/ITKWikiArchive/Wiki/ITK/Release_4/UnitTesting"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-ITK_Release_4_UnitTesting rootpage-ITK skin-monobook action-view skin--responsive"><!-- start content -->
				<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#ITK_v4_Unit_Testing_Framework"><span class="tocnumber">1</span> <span class="toctext">ITK v4 Unit Testing Framework</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Unit_and_regression_testing_concepts"><span class="tocnumber">1.1</span> <span class="toctext">Unit and regression testing concepts</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-3"><a href="#Unit_testing_proposal"><span class="tocnumber">2</span> <span class="toctext">Unit testing proposal</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Unit_testing_basics_tutorial"><span class="tocnumber">3</span> <span class="toctext">Unit testing basics tutorial</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Setup"><span class="tocnumber">3.1</span> <span class="toctext">Setup</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#First_tests"><span class="tocnumber">3.2</span> <span class="toctext">First tests</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Test_failure"><span class="tocnumber">3.3</span> <span class="toctext">Test failure</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Image_test"><span class="tocnumber">3.4</span> <span class="toctext">Image test</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Image_comparison"><span class="tocnumber">3.5</span> <span class="toctext">Image comparison</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#Test_Fixtures"><span class="tocnumber">4</span> <span class="toctext">Test Fixtures</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#RecursiveGaussianImageFilter_test_fixture"><span class="tocnumber">4.1</span> <span class="toctext">RecursiveGaussianImageFilter test fixture</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-12"><a href="#Where_to_go_from_here"><span class="tocnumber">5</span> <span class="toctext">Where to go from here</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="ITK_v4_Unit_Testing_Framework">ITK v4 Unit Testing Framework</span></h2>
<p>Many of the existing ITK 3.20 tests were written for the purpose of testing methods and increasing code coverage.  These tests accomplish this task exceedingly well, as code coverage for ITK 3.20 testing exceeds 70% of the entire toolkit.  Some of the tests evaluate outputs to validate correctness of filter results.  In ITK v4, the <a rel="nofollow" class="external text" href="http://code.google.com/p/googletest/">Google Testing</a> framework will be added to assist developers in writing sound unit tests.
</p>
<h3><span class="mw-headline" id="Unit_and_regression_testing_concepts">Unit and regression testing concepts</span></h3>
<p>Formal unit and regression testing helps developers of ITK assure correct behavior of the toolkit.  Characteristics of a good unit/regression test framework are:
</p>
<ul><li>Tests clearly test one discrete unit of functionality</li>
<li>Tests verify output(s) of code against a regression standard</li>
<li>Tests are simple to read and write by developers</li></ul>
<p>The <a rel="nofollow" class="external text" href="http://code.google.com/p/googletest/">Google Test framework</a> is a well designed and <a rel="nofollow" class="external text" href="http://code.google.com/p/googletest/wiki/GoogleTestPrimer">thoroughly documented</a> unit test framework.  Google Test (GTest) is a natural fit with the ctest/CDash framework.  GTest creates and manages individual tests, ctest executes GTest recording the results and posts to CDash.  GTest is also <a href="/Wiki/Proposals:Increasing_ITK_Code_Coverage" title="Proposals:Increasing ITK Code Coverage">well integrated with CMake</a>.
</p>
<h2><span class="mw-headline" id="Unit_testing_proposal">Unit testing proposal</span></h2>
<p>An integrated Google Test framework has been proposed for ITK v4.  This combines Google Testing with ITK specific utilities to aid the developer in writing solid unit tests.  A draft implementation has been completed and is available on Github in a topic branch (<a rel="nofollow" class="external text" href="http://github.com/dblezek/ITK/tree/djb/UnitTesting">http://github.com/dblezek/ITK/tree/djb/UnitTesting on Github</a>).
</p>
<h2><span class="mw-headline" id="Unit_testing_basics_tutorial">Unit testing basics tutorial</span></h2>
<p>The new unit testing framework leverages GTest and some utility functions specific for ITK.  This tutorial will demonstrate many features of the new ITK testing framework (ITKTestHarness).  This example show the stages of writing an ITK test, progressing from simple concepts to more complex.
</p>
<h4><span class="mw-headline" id="Setup">Setup</span></h4>
<p>In this tutorial, we are going to write a test suite or test group for recursive gaussian smoothing available in ITK (<a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1RecursiveGaussianImageFilter.html">itkRecursiveGaussianImageFilter</a>).  The first step in the process is to create a new file in the appropriate directory.  Our TestGroup will be GaussianImageFilter, so we create the file Testing/Unit/BasicFilters/itkGaussianImageFilterTests.cxx.  To let CMake know about our test we edit the CMakeLists.txt file in Testing/Unit/BasicFilters to include our new file:
</p>
<pre>set(BasicFiltersTestSource 
 itkRecursiveGaussianImageFilterUnitTests.cxx )
</pre>
<h4><span class="mw-headline" id="First_tests">First tests</span></h4>
<p>Next, we will create an edit itkRecursiveGaussianImageFilterUnitTests.cxx:
</p>
<pre>#include "itkTestHarness.h"

TEST(RecursiveGaussianImageFilter,Basics)
{
  ASSERT_TRUE ( true );
}

</pre>
<p>The first line includes the new ITK test harness.
</p>
<pre>#include "itkTestHarness.h"
</pre>
<p>We define a test:
</p>
<pre>TEST(RecursiveGaussianImageFilter,Basics)
</pre>
<p>The <b>TEST</b> macro is provided by Google Test.  The first argument is the TestGroup or TestSuite name.  The second argument is the name of the test to run.  In our case, we have added a test called RecursiveGaussianImageFilter.Basics
</p><p>Looking at the body of the test we see:
</p>
<pre>ASSERT_TRUE ( true );
</pre>
<p>ASSERT_TRUE is another Google Test macro.  It's function is to ensure the body of the macro evaluates to true.  If the body is true, the test continues, if the body evaluates to false, the test stops and prints out an error message.  If we compile and run ctest, we see that the tests pass:
</p>
<pre>Test project /Users/blezek/Source/ITK-macosx
    Start 3: RecursiveGaussianImageFilter.Basics
3/4 Test #3: RecursiveGaussianImageFilter.Basics .......   Passed    0.01 sec
</pre>
<p>Under the hood, ctest is running Google Tests:
</p>
<pre>3: Test command: /Users/blezek/Source/ITK-macosx/bin/itkBasicFiltersUnitTests --gtest_filter=RecursiveGaussianImageFilter.Basics /Users/blezek/Source/ITK/Testing/Data /Users/blezek/Source/ITK-macosx/Testing/Temporary
3: Test timeout computed to be: 1500
3: Note: Google Test filter = RecursiveGaussianImageFilter.Basics
3: [==========] Running 1 test from 1 test case.
3: [----------] Global test environment set-up.
3: [----------] 1 test from GaussianImageFilter
3: [ RUN      ] RecursiveGaussianImageFilter.Basics
3: [       OK ] RecursiveGaussianImageFilter.Basics (0 ms)
3: [----------] 1 test from RecursiveGaussianImageFilter (1 ms total)
3: 
3: [----------] Global test environment tear-down
3: [==========] 1 test from 1 test case ran. (1 ms total)
3: [  PASSED  ] 1 test.
3/4 Test #3: RecursiveGaussianImageFilter.Basics .....   Passed    0.01 sec
</pre>
<p>The extra output is generated by Google test.
</p>
<h4><span class="mw-headline" id="Test_failure">Test failure</span></h4>
<p>Now, let's see what happens if we fail a test.  Modify the body of RecursiveGaussianImageFilter.Basics to be:
</p>
<pre>TEST(RecursiveGaussianImageFilter,Basics)
{
  EXPECT_TRUE ( false ) &lt;&lt; "Continue anyway";
  ASSERT_TRUE ( false ) &lt;&lt; "Stop running the test";
  ASSERT_TRUE ( false ) &lt;&lt; "Never gets here";
}
</pre>
<p>This introduces the EXPECT_TRUE macro.  EXPECT_TRUE evaluates it's body, if it evaluates to false, the test continues, but a failure is recorded for the test.  The macro allows a text string to be piped in using the '&lt;&lt;' syntax to record the purpose of the test.  In the code above, the test will fail on the EXPECT_TRUE, but continue to the first ASSERT_TRUE.  This macro halts the test, so the second ASSERT_TRUE is never run.  ASSERT's are typically used when a failure is fatal, while EXPECT's are used when the test failed, but it is safe to run the rest of the test.
</p><p>When we run ctest we see:
</p>
<pre>4: [==========] Running 1 test from 1 test case.
4: [----------] Global test environment set-up.
4: [----------] 1 test from RecursiveGaussianImageFilter
4: [ RUN      ] RecursiveGaussianImageFilter.Basics
4: /Users/blezek/Source/ITK/Testing/Unit/BasicFilters/itkRecursiveGaussianImageFilterUnitTests.cxx:25: Failure
4: Value of: false
4:   Actual: false
4: Expected: true
4: Continue anyway
4: /Users/blezek/Source/ITK/Testing/Unit/BasicFilters/itkRecursiveGaussianImageFilterUnitTests.cxx:26: Failure
4: Value of: false
4:   Actual: false
4: Expected: true
4: Stop running the test
4: [  FAILED  ] RecursiveGaussianImageFilter.Basics (0 ms)
4: [----------] 1 test from RecursiveGaussianImageFilter (0 ms total)
4: 
4: [----------] Global test environment tear-down
4: [==========] 1 test from 1 test case ran. (0 ms total)
4: [  PASSED  ] 0 tests.
4: [  FAILED  ] 1 test, listed below:
4: [  FAILED  ] RecursiveGaussianImageFilter.Basics
4: 
4:  1 FAILED TEST
4/4 Test #4: GRecursiveGaussianImageFilter.Basics ....***Failed    0.01 sec
</pre>
<p>In the output above, we can see the 'Continue anyway' message and the line the failure came from (line 25) as well as the 'Stop running the test' message.  This helps the developer quickly understand why the test was failing.
</p>
<h4><span class="mw-headline" id="Image_test">Image test</span></h4>
<p>We now edit the test to include the proper header files, and load an image.  This code snippit introduces helper functions defined in the ITKTestHarness.
</p>
<pre>typedef itk::Image&lt;float,3&gt; FloatImage;
TEST(RecursiveGaussianImageFilter,Basics)
{
  typedef itk::RecursiveGaussianImageFilter&lt;FloatImage, FloatImage&gt;  GaussianFilterType;
  GaussianFilterType::Pointer filter = GaussianFilterType::New();
  FloatImage::Pointer image = LoadImage&lt;FloatImage&gt; ( dataFinder.GetFile ( "Input/HeadMRVolumeWithDirection.nhdr" ) );
  filter-&gt;SetInput ( image );
  ASSERT_EQ ( "", ImageSHA1Hash&lt;FloatImage&gt; ( filter-&gt;GetOutput() ) ) &lt;&lt; "Failed to match the hash";
}
</pre>
<p>The first helper is dataFinder.  dataFinder is a small helper class to assist in determining file names.  The GetFile() method returns a filename in the ITK_DATA_ROOT directory.  In this case, we would like to find Input/HeadMRVolumeWithDirection.nrdr.  The next helper is LoadImage().  LoadImage is templated over the image datatype, and simply loads an image from the filename passed as an argument.  These two helper functions avoid much repetitious code when writing tests.
</p><p>The third helper function is ImageSHA1Hash().  This helper function computes a [<a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Sha1">SHA1 hash</a>] of the image, and it's origin, spacing and directions.  In this way, we can be sure that a filter produces exactly the same output each time it is run.  If we compile and run this code, we see it fails because the hash does not match.
</p>
<pre>4: [ RUN      ] RecursiveGaussianImageFilter.Basics
4: /Users/blezek/Source/ITK/Testing/Unit/BasicFilters/itkRecursiveGaussianImageFilterUnitTests.cxx:33: Failure
4: Value of: ImageSHA1Hash&lt;FloatImage&gt; ( filter-&gt;GetOutput() )
4:   Actual: "93081d5322d29724e8ff49874f6b0d925adb5c1c"
4: Expected: ""
4: Failed to match the hash
</pre>
<p>If we copy the SHA1 of the image into the test, we have now documented the exact output this filter should produce each time it is run.
</p>
<pre>ASSERT_EQ ( "93081d5322d29724e8ff49874f6b0d925adb5c1c", ImageSHA1Hash&lt;FloatImage&gt; ( filter-&gt;GetOutput() ) ) &lt;&lt; "Failed to match the hash";
</pre>
<p>However, the RecursiveGaussianFilter may produce different results on other platform.  This will be examined in the next section.
</p>
<h4><span class="mw-headline" id="Image_comparison">Image comparison</span></h4>
<p>Different platforms have differing levels of numeric precision.  Because of this, a SHA1 hash value will not be valid on all platforms unless the filter is designed to produce exactly the same output independent of numeric precision (morphology filters for instance).  The testing harness provides several helper macros that operate exactly like the Google Test macros.  These helpers operate on images and require a few extra bits of information.
</p>
<pre>  EXPECT_IMAGE_NEAR(FloatImage, filter-&gt;GetOutput(), "float", 1.0);
  filter-&gt;SetSigma( 2.0 );
  filter-&gt;SetZeroOrder();
  EXPECT_IMAGE_NEAR(FloatImage, filter-&gt;GetOutput(), "sigma_2.0", 1.0);
</pre>
<p>The macros are:
</p>
<pre>#define EXPECT_IMAGE_EQ(ImageType, image, name)
#define EXPECT_IMAGE_NEAR(ImageType, image, name, tolerance)
#define ASSERT_IMAGE_EQ(ImageType, image, name)
#define ASSERT_IMAGE_NEAR(ImageType, image, name, tolerance)
</pre>
<p>The first argument is the type of the image and is used to instantiate the correct reading and comparison classes.  The image argument is the actual image produced during this run of the test.  The name specifies which image this is.  Generally speaking, a test may execute a filter several times producing different images each time.  The name is used to construct the baseline image file on disk.  The tolerance argument for the "_NEAR" functions provide a threshold for the image difference from baseline.  Running the test at this stage produces this output.
</p>
<pre>3: /Users/blezek/Source/ITK/Testing/Unit/BasicFilters/itkRecursiveGaussianImageFilterUnitTests.cxx:33: Failure
3: Value of: imageCompare.Compare (filter-&gt;GetOutput(), "float", 1.0)
3:   Actual: false
3: Expected: true
3: Baseline does not exist, wrote /Users/blezek/Source/ITK-macosx/Testing/Temporary/Newbaseline/RecursiveGaussianImageFilter_Basics_float.nrrd
3: cp /Users/blezek/Source/ITK-macosx/Testing/Temporary/Newbaseline/RecursiveGaussianImageFilter_Basics_float.nrrd /Users/blezek/Source/ITK/Testing/Data//Baseline/RecursiveGaussianImageFilter_Basics_float.nrrd
3: /Users/blezek/Source/ITK/Testing/Unit/BasicFilters/itkRecursiveGaussianImageFilterUnitTests.cxx:36: Failure
3: Value of: imageCompare.Compare (filter-&gt;GetOutput(), "sigma_2.0", 1.0)
3:   Actual: false
3: Expected: true
3: Baseline does not exist, wrote /Users/blezek/Source/ITK-macosx/Testing/Temporary/Newbaseline/RecursiveGaussianImageFilter_Basics_sigma_2.0.nrrd
3: cp /Users/blezek/Source/ITK-macosx/Testing/Temporary/Newbaseline/RecursiveGaussianImageFilter_Basics_sigma_2.0.nrrd /Users/blezek/Source/ITK/Testing/Data//Baseline/RecursiveGaussianImageFilter_Basics_sigma_2.0.nrrd
3: [  FAILED  ] RecursiveGaussianImageFilter.Basics (69 ms)
3: [----------] 1 test from RecursiveGaussianImageFilter (69 ms total)
3: 
3: [----------] Global test environment tear-down
3: [==========] 1 test from 1 test case ran. (69 ms total)
3: [  PASSED  ] 0 tests.
3: [  FAILED  ] 1 test, listed below:
3: [  FAILED  ] RecursiveGaussianImageFilter.Basics
3: 
3:  1 FAILED TEST
3/3 Test #3: RecursiveGaussianImageFilter.Basics ...***Failed    0.09 sec

</pre>
<p>On the first run, the test failed because no baseline existed.  EXPECT_IMAGE_NEAR writes the image to disk in the temporary directory.  Since we used the EXPECT version of the macro, the test continued and wrote the second baseline image.  The naming convention for the files in TestGroup_Test_name.png; this example wrote GaussianImageFilter_Recursive_float.nrrd and GaussianImageFilter_Recursive_sigma_2.0.nrrd.  If we take a look at the image we see (slice 16):
<a href="/Wiki/File:GaussianImageFilter_Recursive_float.png" class="image"><img alt="GaussianImageFilter Recursive float.png" src="/Wiki/images/a/a0/GaussianImageFilter_Recursive_float.png" decoding="async" width="48" height="62" /></a>
</p><p>The image is fairly small because the input image is very small.  After we examine these images, we can copy them to the Baseline image directory in ITK_DATA_ROOT and make them available for other to use.  The macro helpfully supplies the proper command line:
</p>
<pre>cp /Users/blezek/Source/ITK-macosx/Testing/Temporary/Newbaseline/RecursiveGaussianImageFilter_Basics_float.nrrd /Users/blezek/Source/ITK/Testing/Data//Baseline/RecursiveGaussianImageFilter_Basics_float.nrrd
cp /Users/blezek/Source/ITK-macosx/Testing/Temporary/Newbaseline/RecursiveGaussianImageFilter_Basics_sigma_2.0.nrrd /Users/blezek/Source/ITK/Testing/Data//Baseline/RecursiveGaussianImageFilter_Basics_sigma_2.0.nrrd
</pre>
<p>Now when we run the testing, the test passes.
</p>
<h2><span class="mw-headline" id="Test_Fixtures">Test Fixtures</span></h2>
<p>Next, let's expand on our simple basics test and create a text fixture.  If a series of tests share similar setup and/or tear down code, it is simple to place them in a fixture.  In Google Test, a fixture is a class derived from&#160;::testing::Test.  The new class can implement a SetUp() and TearDown() method.  Let's see what this looks like.
</p>
<h4><span class="mw-headline" id="RecursiveGaussianImageFilter_test_fixture">RecursiveGaussianImageFilter test fixture</span></h4>
<p>Suppose we want to test a gaussian filter on both short and float image data types.  We have a number of tests that we would like to run that all follow the pattern: load images, set parameters, compare results.  Test fixtures reduce the code duplication by moving initialization code into a SetUp() method that is called before each test run.
</p><p>The fixture class looks like this:
</p>
<pre>typedef itk::Image&lt; float, 3 &gt; FloatImage;
typedef itk::Image&lt; short, 3 &gt; ShortImage;
typedef itk::RecursiveGaussianImageFilter&lt; FloatImage, FloatImage &gt; GaussianFilterType;
typedef itk::RecursiveGaussianImageFilter&lt; ShortImage, ShortImage &gt; GaussianFilterTypeShort;

class RecursiveGaussianImageFilter&#160;: public&#160;::testing::Test
{
public:
  virtual void SetUp()
  {
    filter = GaussianFilterType::New();
    filterShort = GaussianFilterTypeShort::New();
    EXPECT_NO_THROW ( floatImage = LoadImage&lt;FloatImage&gt; ( dataFinder.GetFile ( "Input/HeadMRVolumeWithDirection.nhdr" ) ) ) &lt;&lt; "Failed to load float volume";
    EXPECT_NO_THROW ( shortImage = LoadImage&lt;ShortImage&gt; ( dataFinder.GetFile ( "Input/HeadMRVolumeWithDirection.nhdr" ) ) ) &lt;&lt; "Failed to load short volume";
  }
  GaussianFilterType::Pointer filter;
  GaussianFilterTypeShort::Pointer filterShort
  FloatImage::Pointer floatImage;
  ShortImage::Pointer shortImage;
};
</pre>
<p>The first thing to notice is that RecursiveGaussianImageFilter derives from&#160;::testing::Test.  In the SetUp() method, we have now wrapped our LoadImage() call in the Google Test macro EXPECT_NO_THROW().  As you might guess, EXPECT_NO_THROW() runs the code in the body and catches any thrown exceptions.  In this way, we ensure that our tests have good data to work on, or they fail in the SetUp() call.
</p><p>Now we change our test.
</p>
<pre>TEST_F(RecursiveGaussianImageFilter, FloatBasics)
{
  filter-&gt;SetInput (floatImage);
  EXPECT_IMAGE_NEAR(FloatImage, filter-&gt;GetOutput(), "float", 1.0);
  filter-&gt;SetSigma(2.0);
  filter-&gt;SetZeroOrder();
  EXPECT_IMAGE_NEAR(FloatImage, filter-&gt;GetOutput(), "sigma_2.0", 1.0);
}
</pre>
<p>Instead of the TEST() macro, we now use TEST_F().  TEST_F() tells Google Test that this test runs in the fixture specified by the test group (RecursiveGaussianImageFilter).  This macro generates an error if the class RecursiveGaussianImageFilter does not exist, or does not publicly derive from&#160;::testing::Test.  The test body is the same as before, except we operate on floatImage, and no longer need to load the data inside the test body.  The baseline image name is derived in exactly the same way as before.  More details on test fixtures can be found in the <a rel="nofollow" class="external text" href="http://code.google.com/p/googletest/wiki/GoogleTestPrimer#Test_Fixtures:_Using_the_Same_Data_Configuration_for_Multiple_Te">Google Test documentation</a>.
</p><p>We can define several other tests in the same fixture:
</p>
<pre>TEST_F(RecursiveGaussianImageFilter, ShortBasics)
{
  filterShort-&gt;SetInput (shortImage);
  EXPECT_IMAGE_NEAR(ShortImage, filterShort-&gt;GetOutput(), "short", 1.0);
  filterShort-&gt;SetSigma(2.0);
  filterShort-&gt;SetZeroOrder();
  EXPECT_IMAGE_NEAR(ShortImage, filterShort-&gt;GetOutput(), "sigma_2.0", 1.0);
}

TEST_F(RecursiveGaussianImageFilter,ZSmoothing)
{
  filter-&gt;SetDirection( 2 );  // apply along Z
  filter-&gt;SetOrder( GaussianFilterType::ZeroOrder );
  filter-&gt;SetInput ( floatImage );
  EXPECT_IMAGE_NEAR(FloatImage, filter-&gt;GetOutput(), "ZeroOrder", 1.0);
  filter-&gt;SetOrder ( GaussianFilterType::FirstOrder );
  EXPECT_IMAGE_NEAR(FloatImage, filter-&gt;GetOutput(), "FirstOrder", 1.0);
  filter-&gt;SetOrder ( GaussianFilterType::SecondOrder );
  EXPECT_IMAGE_NEAR(FloatImage, filter-&gt;GetOutput(), "SecondOrder", 1.0);
}
</pre>
<p>One thing to remember: since CMake is responsible for finding tests in the framework, if you add a test to an existing file, you must re-run CMake to have the test executed during the next run of ctest.  In practice this is rarely a problem.
</p>
<h2><span class="mw-headline" id="Where_to_go_from_here">Where to go from here</span></h2>
<p>We have covered the basics of the proposed ITK v4 unit testing.  For further information regarding Google Test, reading the <a rel="nofollow" class="external text" href="http://code.google.com/p/googletest/wiki/GoogleTestPrimer">primer</a> and <a rel="nofollow" class="external text" href="http://code.google.com/p/googletest/wiki/GoogleTestAdvancedGuide">advanced guides</a> are recommended.
</p>
<!-- 
NewPP limit report
Cached time: 20220626203809
Cache expiry: 86400
Reduced expiry: false
Complications: []
CPU time usage: 0.014 seconds
Real time usage: 0.015 seconds
Preprocessor visited node count: 108/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 8005/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key KitwarePublicWikiDB:pcache:idhash:6705-0!canonical and timestamp 20220626203809 and revision id 44207. Serialized with JSON.
 -->
</div>
<div class="printfooter">Retrieved from "<a dir="ltr" href="https://public.kitware.com/Wiki/index.php?title=ITK/Release_4/UnitTesting&amp;oldid=44207">https://public.kitware.com/Wiki/index.php?title=ITK/Release_4/UnitTesting&amp;oldid=44207</a>"</div></div>
				<div id="catlinks" class="catlinks catlinks-allhidden" data-mw="interface"></div>
				<!-- end content --></body></html>