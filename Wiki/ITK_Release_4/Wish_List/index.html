<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>ITK Release 4/Wish List</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"4cecf86535e69b35ee085298","wgCSPNonce":false,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"ITK_Release_4/Wish_List","wgTitle":"ITK Release 4/Wish List","wgCurRevisionId":31276,"wgRevisionId":31276,"wgArticleId":5601,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"ITK_Release_4/Wish_List","wgRelevantArticleId":5601,"wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]};RLSTATE={"site.styles":"ready","user.styles":
"ready","user":"ready","user.options":"loading","skins.monobook.styles":"ready"};RLPAGEMODULES=["site","mediawiki.page.ready","mediawiki.toc","skins.monobook.scripts"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@1i9g4",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script>
<link rel="stylesheet" href="/Wiki/load.php?lang=en&amp;modules=skins.monobook.styles&amp;only=styles&amp;skin=monobook"/>
<script async="" src="/Wiki/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=monobook"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="/Wiki/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=monobook"/>
<meta name="generator" content="MediaWiki 1.38.6"/>
<meta name="format-detection" content="telephone=no"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0"/>
<link rel="shortcut icon" href="/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="/Wiki/opensearch_desc.php" title="KitwarePublic (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://public.kitware.com/Wiki/api.php?action=rsd"/>
<link rel="license" href="https://creativecommons.org/licenses/by/2.5/"/>
<link rel="alternate" type="application/atom+xml" title="KitwarePublic Atom feed" href="/Wiki/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-ITK_Release_4_Wish_List rootpage-ITK_Release_4 skin-monobook action-view skin--responsive"><!-- start content -->
				<div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><p>The wish list is provided by members of the ITK development community.
These requests are not necessarily included in the NLM-funded ITKv4 and ITKv4 A2D2 contracts.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Oriented_Images"><span class="tocnumber">1</span> <span class="toctext">Oriented Images</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Image_Representation"><span class="tocnumber">2</span> <span class="toctext">Image Representation</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Statistics"><span class="tocnumber">3</span> <span class="toctext">Statistics</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#FEM_Meshes"><span class="tocnumber">4</span> <span class="toctext">FEM Meshes</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Backward_compatibility_and_cleanup"><span class="tocnumber">5</span> <span class="toctext">Backward compatibility and cleanup</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Image_Registration"><span class="tocnumber">6</span> <span class="toctext">Image Registration</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Composite_Transform"><span class="tocnumber">7</span> <span class="toctext">Composite Transform</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Architecture_and_Software_engineering"><span class="tocnumber">8</span> <span class="toctext">Architecture and Software engineering</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#Internationalization"><span class="tocnumber">9</span> <span class="toctext">Internationalization</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Proper_resampling/consistency_in_IndexToPhysicalPoint,_ContinuousIndexToPhysicalPoint,_Point*"><span class="tocnumber">10</span> <span class="toctext">Proper resampling/consistency in IndexToPhysicalPoint, ContinuousIndexToPhysicalPoint, Point*</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#Deformable_Organisms"><span class="tocnumber">11</span> <span class="toctext">Deformable Organisms</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Make_as_much_filters_as_possible_able_to_run_in_place"><span class="tocnumber">12</span> <span class="toctext">Make as much filters as possible able to run in place</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Make_the_boundary_conditions_usage_consistent_across_the_toolkit"><span class="tocnumber">13</span> <span class="toctext">Make the boundary conditions usage consistent across the toolkit</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Replace_the_current_implementation_of_Marching_Cubes_and_add_a_4D_version"><span class="tocnumber">14</span> <span class="toctext">Replace the current implementation of Marching Cubes and add a 4D version</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Normalize_the_Binary/Label/Grayscale_usage_in_code_and_in_the_class_names"><span class="tocnumber">15</span> <span class="toctext">Normalize the Binary/Label/Grayscale usage in code and in the class names</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#Use_an_image_template_parameter_in_the_complex_related_filters"><span class="tocnumber">16</span> <span class="toctext">Use an image template parameter in the complex related filters</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#Arbitrary_precision_type"><span class="tocnumber">17</span> <span class="toctext">Arbitrary precision type</span></a></li>
<li class="toclevel-1 tocsection-18"><a href="#Exact_geometrical_test_(point_in_circle_=&gt;_delaunay"><span class="tocnumber">18</span> <span class="toctext">Exact geometrical test (point in circle =&gt; delaunay</span></a></li>
<li class="toclevel-1 tocsection-19"><a href="#3rd_Party_Libraries"><span class="tocnumber">19</span> <span class="toctext">3rd Party Libraries</span></a></li>
<li class="toclevel-1 tocsection-20"><a href="#Coding_Style"><span class="tocnumber">20</span> <span class="toctext">Coding Style</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="#Wavelets_Framework"><span class="tocnumber">21</span> <span class="toctext">Wavelets Framework</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="#Label_map_writer"><span class="tocnumber">22</span> <span class="toctext">Label map writer</span></a></li>
<li class="toclevel-1 tocsection-23"><a href="#DICOM"><span class="tocnumber">23</span> <span class="toctext">DICOM</span></a></li>
<li class="toclevel-1 tocsection-24"><a href="#Support_clang_compiler"><span class="tocnumber">24</span> <span class="toctext">Support clang compiler</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Oriented_Images">Oriented Images</span></h2>
<ul><li>Support ND image in N+1 dimension
<ul><li>2D image can have an origin specified in 3D, thus a series of 2D images is not always Z-aligned</li>
<li>Support ND images in M dimensions where M &gt; N.</li></ul></li>
<li>All images are oriented - remove concept of an un-oriented image</li>
<li>Check use of orientation throughout ITK</li>
<li>Support re-orientation of ND oriented images
<ul><li>Using anything other than 3D images won't compile with itkOrientedImageFilter</li></ul></li></ul>
<ul><li><ul><li>Spatial Objects</li>
<li>Meshes</li></ul></li>
<li>Suggestions
<ul><li><a href="/Wiki/ITK_Release_4.0_Orientation_by_Kent" title="ITK Release 4.0 Orientation by Kent">ITK_Release_4.0_Orientation_by_Kent</a></li>
<li><a href="/Wiki/ITK_Release_4.0_Orientation_by_Torsten" title="ITK Release 4.0 Orientation by Torsten">ITK_Release_4.0_Orientation_by_Torsten</a></li>
<li><a href="/Wiki/ITK_Release_4.0_Orientation_by_Michael" title="ITK Release 4.0 Orientation by Michael">ITK_Release_4.0_Orientation_by_Michael</a></li>
<li><a rel="nofollow" class="external text" href="http://wiki.na-mic.org/Wiki/index.php/Complex_Image_Set">Some notes on complex image acquisitions by Steve and Greg</a></li></ul></li></ul>
<h2><span class="mw-headline" id="Image_Representation">Image Representation</span></h2>
<ul><li>Allow the use of strides that are not equal to the image width
<ul><li>Would ease the collaboration of ITK with opencv</li>
<li>Would allow the use of sse operations</li>
<li>Might be considered redundant with correct use of image regions but is not since GetLargestPossibleRegion should correspond to the image width and not its stride</li></ul></li>
<li>Drop the itk::Image::GetBufferPointer() method
<ul><li>This method has been many time described as a problem to implement new image layouts.</li>
<li>As expressed above, we need however to be able to use the memory held by ITK images within other libraries. This could potentially be done by making itk::Image be only a base class that has no knowledge of the memory layout and by implementing different image subclasses.</li></ul></li>
<li>Consider replacing ImportImageContainer by std::vector or using std::vector to implement it
<ul><li>This would give STL iterators that operate on the whole image literally for free and make it easy to use a lot of algorithms implemented in STL and BOOST</li>
<li><a rel="nofollow" class="external text" href="http://www.boost.org/doc/libs/1_39_0/libs/gil/doc/index.html">Boost gil</a> also offers a compelling alternative for memory management of images. Unfortunately it seems to be still focused on 2D</li>
<li><b>Lorensen:</b> ITK images are n-dimensional. The current iterator design enables that required functionality. If I recall, stl iterators were considered but did not meet the n-d requirements.</li></ul></li>
<li>See <a rel="nofollow" class="external text" href="http://hdl.handle.net/10380/3068">Alternative Memory Models for ITK Images</a> on the Insight Journal for an initial implementation of such ideas</li>
<li>Discuss a proper way of handling dynamic images (2D+t is not really 3D and 3D+t is difficult in terms of memory management)</li></ul>
<h2><span class="mw-headline" id="Statistics">Statistics</span></h2>
<ul><li>Complete statistics refactoring (see NAMIC sandbox)</li></ul>
<h2><span class="mw-headline" id="FEM_Meshes">FEM Meshes</span></h2>
<ul><li><a href="/Wiki/Refactoring_itk::FEM_framework_-_V4" title="Refactoring itk::FEM framework - V4">Refactoring itk::FEM framework - V4</a></li>
<li>Consolidate FEM Meshes and ITK Meshes</li></ul>
<h2><span class="mw-headline" id="Backward_compatibility_and_cleanup">Backward compatibility and cleanup</span></h2>
<ul><li>Clean-up CMake Vars ==
<ul><li>See proposal <a href="/Wiki/ITK_CMake_Style" title="ITK CMake Style">HERE</a>.</li></ul></li>
<li>Remove Deprecated Features
<ul><li>Functions that have been deprecated (and appropriately marked as such) for more than 3 releases should be removed.</li></ul></li>
<li>Modify the itkSetMacro to use a const reference argument, i.e. #define itkSetMacro(name,type) virtual void Set##name (const type &amp; _arg)
<ul><li>This cannot be done int ITK 3.x because of backward compatibility issues</li></ul></li>
<li>Make the semantics of the ITK containers match th one from STL
<ul><li>See this <a rel="nofollow" class="external text" href="http://www.itk.org/Bug/view.php?id=2893">bug report</a></li></ul></li>
<li>Set the default options values to provide the highest result quality
<ul><li>Some filters have default options values to produce quick transforms rather than high quality transforms. This is the case for the distance map filters, which produced squared results and don't use image spacing by default. This behavior is desirable in some conditions, but shouldn't be the default one.</li></ul></li>
<li>Supported compilers
<ul><li>We should reconsider the list of supported compilers. ITK 4.0 might be a good time to drop, for example, MSVC 6.0 that only implements a subset of modern C++.</li>
<li>I would even suggest to go so far as to pick a very small set of very recent compilers that already implement support for parts of the new, upcoming C++0x standard. Especially, auto typeing, static_assert and maybe lambda expressions should be available for writing new code.</li></ul></li>
<li>Define a transition period during which developments need not be backward compatible
<ul><li>Such a period could be defined in terms of a number of "beta" releases</li></ul></li></ul>
<h2><span class="mw-headline" id="Image_Registration">Image Registration</span></h2>
<ul><li>Set up the infrastructure to ease the implementation of modern optimization schemes for image registration
<ul><li>Requires Hessian or pseudo-Hessians of the cost function</li>
<li>Requires several types of update rules (additive, compositional, inverse compositional, etc.)</li>
<li>References: "Lucas-Kanade 20 years on" by Baker et al.; "Homography-based 2D Visual Tracking and Servoing" by Benhimane and Malis, "Groupwise Geometric and Photometric Direct Image Registration" by Bartoli; etc.</li></ul></li>
<li>Allow the use of regularization terms that depends on the spatial transformation.
<ul><li>See <a rel="nofollow" class="external text" href="http://elastix.isi.uu.nl/doxygen/a00010.html">elastix</a> for an example implementation.</li>
<li>See <a rel="nofollow" class="external text" href="http://hdl.handle.net/10380/3215">this InsightJournal article</a></li></ul></li>
<li>Clean up the use of parameter scaling in the optimizers
<ul><li>One possibility would be that the optimizers only perform unscaled minimization. It would then be up to a cost function wrapper to do the rescaling and potentially return the opposite of the cost function. This is similar to how vnl optimizers are used in ITK</li>
<li>See also <a rel="nofollow" class="external text" href="http://elastix.isi.uu.nl/doxygen/a00193.html">elastix</a> for another example implementation.</li></ul></li>
<li>Optimizers should return the best visited value
<ul><li>See <a rel="nofollow" class="external text" href="http://public.kitware.com/Bug/bug_view_page.php?bug_id=3205">Bug 3205</a></li></ul></li>
<li>Modify transforms to support a consistent API across transform types</li>
<li>Modify order of parameters to be consistent across transforms.</li>
<li>Modify the base class for optimizers to support key optimizer API calls such as SetMaximize and SetNumberOfIterations or SetMaximumIteration</li>
<li>Make the registration framework work with vector images natively.
<ul><li>Currently several itk filters/functions assume that the pixel is of scalar type. This prevents from using the registration framework with vector images.</li>
<li>Several filters/functions useful for registration are specialized for vectors whereas it is often unnecessary. It is often quite easy to adapt the filters that assume scalar pixels to make them work with vector pixels. For example, there is a <a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1VectorInterpolateImageFunction.html">VectorInterpolateImageFunction</a>, but the regular <a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1InterpolateImageFunction.html">InterpolateImageFunction</a> should do just fine. Actually, there is even a <a rel="nofollow" class="external text" href="http://www.itk.org/cgi-bin/viewcvs.cgi/Testing/Code/Common/itkLinearInterpolateImageFunctionTest.cxx?root=Insight&amp;sortby=date&amp;view=markup">unit test</a> to check that the <a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1LinearInterpolateImageFunction.html">LinearInterpolateImageFunction</a> correctly handles vector images. Below is a list of filters that could potentially be removed:
<ul><li><a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1VectorCastImageFilter.html">VectorCastImageFilter</a>: could be reworked if we provide a conversion operator in the vector pixel class</li>
<li><a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1VectorCentralDifferenceImageFunction.html">VectorCentralDifferenceImageFunction</a></li>
<li><a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1VectorExpandImageFilter.html">VectorExpandImageFilter</a></li>
<li><a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1VectorImageNeighborhoodAccessorFunctor.html">VectorImageNeighborhoodAccessorFunctor</a></li>
<li><a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1VectorInterpolateImageFunction.html">VectorInterpolateImageFunction</a></li>
<li><a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1VectorResampleImageFilter.html">VectorResampleImageFilter</a></li>
<li><a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1VectorRescaleIntensityImageFilter.html">VectorRescaleIntensityImageFilter</a></li>
<li><a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1VectorRescaleIntensityImageFilter.html">VectorRescaleIntensityImageFilter</a></li>
<li><a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1VectorNeighborhoodInnerProduct.html">VectorNeighborhoodInnerProduct</a></li>
<li><a rel="nofollow" class="external text" href="http://www.itk.org/Doxygen/html/classitk_1_1VectorNearestNeighborInterpolateImageFunction.html">VectorNearestNeighborInterpolateImageFunction</a></li>
<li>etc.</li></ul></li>
<li>In cases where the implementation has to be slightly different for vector pixels, we should consider using partial template specialization.
<ul><li>This would require dropping support for visual c++ 6.</li></ul></li>
<li>An initial simple implementation of vector image registration can be found on the <a rel="nofollow" class="external text" href="http://www.na-mic.org/svn/NAMICSandBox/trunk/VectorImageRegistrationMethod/">NAMIC SandBox</a>.</li>
<li>Refactor the SymmetricSecondRankTensor to make possible to use it as pixel type for any filter that can process an image of multiple components.
<ul><li>This requires to make "Dimension" equal to the current "InternalDimension".</li></ul></li></ul></li></ul>
<h2><span class="mw-headline" id="Composite_Transform">Composite Transform</span></h2>
<ul><li>Define a composite transform which can contain any number of transforms, composed.</li>
<li>Only expose the parameters of the last transform for optimization (default)</li>
<li>Used in multivariate atlas formation (DTI reg with T1 reg with atlas)</li>
<li>Remove all of the Centered transforms</li>
<li>See Insight Journal Papers:
<ul><li><a rel="nofollow" class="external free" href="http://www.insight-journal.org/browse/publication/143">http://www.insight-journal.org/browse/publication/143</a></li>
<li><a rel="nofollow" class="external free" href="http://www.insight-journal.org/browse/publication/91">http://www.insight-journal.org/browse/publication/91</a></li></ul></li></ul>
<h2><span class="mw-headline" id="Architecture_and_Software_engineering">Architecture and Software engineering</span></h2>
<ul><li>Implement a pure virtual base class for each API to support instantiation of templated filters at run-time with different dimensions. Many classes in ITK are templated, for example over spatial dimension and pixel type, or over images that are templated over spatial dimension and pixel type. However, many of the operations that are carried out do not depend on the spatial dimension and pixel type. A pure virtual base class for a particular filter, such as itk::ResampleImageFilter, would define the API of the ResampleImageFilter without implementing any of the functions that depend on TInputImage, TOutputImage or TInterpolatorPrecisionType. This would enable a pointer to the virtual base class to be manipulated in code, and a specialized implementation with a particular TInputImage, TOutputImage and TInterpolatePrecisionType to be instantiated at run time. This would enable an image to be read in, its dimension and pixel type to be established at run time, an appropriate specialized class to be instantiated and used, rather than the current practice of fixing at compile time the dimension and pixel type that will be utilized. For example, a single program could be written using the virtual base class API with run-time instantiation of a 2D filter for floating point pixels if the input is a 2D with floating point pixels, and a 3D filter with unsigned short pixels if the input is 3D with unsigned short pixels.</li></ul>
<p><i>Can you explain a bit more?</i>
</p>
<ul><li>Add interfaces to the algorithms that turn incomplete initialization into compile time error for "linear" environments or enable some kind of validation  instead of throwing an exception in "dynamic" environments. In both cases, the entry points to doing real work of the algorithm should then be guarded by assertions regarding the required parameters, not exceptions - since ending up there without proper initialization would always be a programming error.
<ul><li>As a "linear" environments I define an implementations where the parameters and the input to an algorithm are completely determined by the program. In this case, an error in initialization (by missing a SetXXX method) usually is a programming error. Adding an initialization method or constructor that takes all required parameters would enable the developer to move this error from run-time to compile-time.</li>
<li>As a "dynamic" environments I imagine e.g. a GUI program, where the user can set the parameters to an algorithm dynamically. Here, a missing SetXXX is not a programming error, but a user error. However, since more than one parameter might be missing, exceptions are not a good way to report the problem. Instead, it should be possible to call some validation function that reports all the missing parameters to the user.</li></ul></li></ul>
<ul><li>Allow partial template specialization, (which would imply <a href="/Wiki/Proposals:Dropping_Support_for_Visual_Studio_6.0" title="Proposals:Dropping Support for Visual Studio 6.0">dropping support for VC 6.0</a>).</li></ul>
<ul><li>Discuss whether to move to TR1. Portability might be achieved through the <a rel="nofollow" class="external text" href="http://www.boost.org/doc/libs/1_39_0/doc/html/boost_tr1.html">boost TR1 wrapper library</a>.</li></ul>
<ul><li>SmartPointer&lt; T &gt; should be implicitly convertible to SmartPointer&lt; U &gt; whenever T* can be implicitly converted to U*.
<ul><li>This might be achieved by using TR1 smart pointers instead of the ITK 3.0 smart pointer implementation. It might however then be more complex to use the default factory mechanism as with <a rel="nofollow" class="external text" href="http://www.itk.org/cgi-bin/viewcvs.cgi/Testing/Code/Common/itkFactoryTestLib.cxx?root=Insight&amp;view=markup">itkFactoryTestLib.cxx</a> and <a rel="nofollow" class="external text" href="http://www.itk.org/cgi-bin/viewcvs.cgi/Testing/Code/Common/itkObjectFactoryTest2.cxx?root=Insight&amp;view=markup">itkObjectFactoryTest2</a>.</li></ul></li></ul>
<ul><li>Testing framework
<ul><li>Add a decent testing framework e.g. based on BOOST.test or googletest; see <a rel="nofollow" class="external text" href="http://www.itk.org/mailman/private/insight-developers/2008-December/011421.html">discussion on the itk-developers</a></li>
<li><a href="/Wiki/ITK_Release_4.0/Testing_Framework" title="ITK Release 4.0/Testing Framework">ITK Release 4.0/Testing Framework</a></li></ul></li></ul>
<ul><li>Code Revision Control
<ul><li>Migrate to Subversion or GIT</li></ul></li></ul>
<ul><li>Portability issues
<ul><li>Discuss the use of fixed-width types to enhance portability and interoperability. This can be done by using <a rel="nofollow" class="external text" href="http://www.boost.org/doc/libs/1_39_0/boost/cstdint.hpp">cstdint from boost</a>.</li>
<li>Avoid the use of tryrun in the cmakelist and rely only on trycompile to ease cross-compilation</li></ul></li></ul>
<h2><span class="mw-headline" id="Internationalization">Internationalization</span></h2>
<ul><li>Allow the use of unicode file names, see this <a rel="nofollow" class="external text" href="http://public.kitware.com/Bug/view.php?id=9623">bug report</a></li></ul>
<h2><span id="Proper_resampling.2Fconsistency_in_IndexToPhysicalPoint.2C_ContinuousIndexToPhysicalPoint.2C_Point.2A"></span><span class="mw-headline" id="Proper_resampling/consistency_in_IndexToPhysicalPoint,_ContinuousIndexToPhysicalPoint,_Point*">Proper resampling/consistency in IndexToPhysicalPoint, ContinuousIndexToPhysicalPoint, Point*</span></h2>
<ul><li>Refactor all the interpolators
<ul><li>See <a href="/Wiki/Proposals:Refactoring_Index_Point_Coordinate_System" title="Proposals:Refactoring Index Point Coordinate System">Proposals:Refactoring Index Point Coordinate System</a></li>
<li>See <a rel="nofollow" class="external text" href="http://www.itk.org/Bug/view.php?id=6558">ITK Bug 6558</a></li>
<li>Fix bug 0005335 - transform initializer computes geometric center incorrectly</li></ul></li></ul>
<h2><span class="mw-headline" id="Deformable_Organisms">Deformable Organisms</span></h2>
<ul><li>Move the framework from the IJ paper:
<ul><li><a rel="nofollow" class="external free" href="http://www.insight-journal.org/browse/publication/116">http://www.insight-journal.org/browse/publication/116</a></li>
<li><a rel="nofollow" class="external free" href="http://hdl.handle.net/1926/228">http://hdl.handle.net/1926/228</a></li></ul></li></ul>
<h2><span class="mw-headline" id="Make_as_much_filters_as_possible_able_to_run_in_place">Make as much filters as possible able to run in place</span></h2>
<p>In place computation is a great way to avoid running out of memory when updating a pipeline. We should review all the existing filters to find the filters which could be implemented that way, and use InPlaceImageFilter has their base class.
Also, a global setting to control the default in place/not in place behavior would be great.
</p>
<h2><span class="mw-headline" id="Make_the_boundary_conditions_usage_consistent_across_the_toolkit">Make the boundary conditions usage consistent across the toolkit</span></h2>
<p>At the moment, some filters let the user provide a boundary condition, some don't but use one internally, and some just don't use them at all. This should be consistent in the toolkit, and if it make sense, it should be changeable by the user.
Boundary conditions also make some filters hard to enhance with much more efficient algorithms - see BoxMeanImageFilter for an example.
</p>
<h2><span class="mw-headline" id="Replace_the_current_implementation_of_Marching_Cubes_and_add_a_4D_version">Replace the current implementation of Marching Cubes and add a 4D version</span></h2>
<p>The itkBinaryMask3DMeshSource filter currently provides the closest functionality to the Marching Cubes algorithm in ITK. However the code of this filter has to be rewritten in order to match the quality standards of the rest of the toolkit. As part of this rewrite we should provide implementations for 2D (marching squares), 3D marching cubes and a 4D version that could be used for segmenting 3D+time datasets.
</p>
<ul><li>See <a rel="nofollow" class="external free" href="http://svn.na-mic.org/NAMICSandBox/trunk/MarchingHypercubes/">http://svn.na-mic.org/NAMICSandBox/trunk/MarchingHypercubes/</a></li></ul>
<h2><span id="Normalize_the_Binary.2FLabel.2FGrayscale_usage_in_code_and_in_the_class_names"></span><span class="mw-headline" id="Normalize_the_Binary/Label/Grayscale_usage_in_code_and_in_the_class_names">Normalize the Binary/Label/Grayscale usage in code and in the class names</span></h2>
<p><a href="/Wiki/Proposals:Consistent_usage_of_label_and_binary_images" title="Proposals:Consistent usage of label and binary images">Proposals:Consistent_usage_of_label_and_binary_images</a>
</p>
<h2><span class="mw-headline" id="Use_an_image_template_parameter_in_the_complex_related_filters">Use an image template parameter in the complex related filters</span></h2>
<h2><span class="mw-headline" id="Arbitrary_precision_type">Arbitrary precision type</span></h2>
<p>for reconstruction and geometry processing, you might want to use arbitrary precision type. Boost has one, GMP is now LGPL.
That also could be a feature of the numerical library, and then the solvers could directly use this, if needed.
</p><p>inspired from exct and filtered kernels in CGAL
</p>
<h2><span id="Exact_geometrical_test_.28point_in_circle_.3D.3E_delaunay"></span><span class="mw-headline" id="Exact_geometrical_test_(point_in_circle_=&gt;_delaunay">Exact geometrical test (point in circle =&gt; delaunay</span></h2>
<p>If we cannot go for arbitrary precision types, in some case it is sufficient to support some operations to have exact geometrical predicates. This is mandatory for a robust delaunay implementation. The implementation for the point-in-circle predicate which is necessary and sufficient for exact 2D delaunay, is public domain.
</p><p>Note that abitrary precision would allow for any exact geometrical predicates.
</p>
<h2><span class="mw-headline" id="3rd_Party_Libraries">3rd Party Libraries</span></h2>
<ul><li>Out dated libraries
<ul><li>Many 3rd party libraries (ex libTIFF) are years out of date.  One possibility is to update them to their newest official release.  Another is to remove them and require developers to use their own version (i.e. USE_SYSTEM_TIFF).</li></ul></li>
<li>Linear algebra package
<ul><li>The current linear algebra package used by ITK is VNL. It's performance and robustness is not very good, it is not actively maintained and cannot use a vendor back-end such as MKL. We should therefore discuss the alternative possibilities. Below is a list of potential linear algebra libraries:</li>
<li>Boost <a rel="nofollow" class="external text" href="http://www.boost.org/doc/libs/release/libs/numeric">uBLAS</a> with <a rel="nofollow" class="external text" href="http://mathema.tician.de/node/391">bindings</a> for LAPACK
<ul><li><a rel="nofollow" class="external text" href="https://svn.boost.org/svn/boost/sandbox/numeric_bindings/">Trunk version of the automatically generated boost bindings</a></li>
<li><a rel="nofollow" class="external text" href="http://mathema.tician.de/software/boost-bindings">Packaged version of the old hand-written version of boost bindings</a></li>
<li>Aside from bindings, uBLAS could also rely on <a rel="nofollow" class="external text" href="http://devernay.free.fr/hacks/ublasJama.html">ublasJama</a> for linear algebra</li></ul></li>
<li><a rel="nofollow" class="external text" href="http://www.mcs.anl.gov/petsc/petsc-as/">PETSc</a></li>
<li><a rel="nofollow" class="external text" href="http://home.gna.org/getfem/gmm_intro.html">GMM++</a></li>
<li><a rel="nofollow" class="external text" href="http://www.cs.uiowa.edu/~dstewart/meschach/">Meschach</a></li>
<li><a rel="nofollow" class="external text" href="http://www.osl.iu.edu/research/mtl/">MTL</a> or <a rel="nofollow" class="external text" href="http://www.osl.iu.edu/research/mtl/mtl4/">MTL4</a></li>
<li><a rel="nofollow" class="external text" href="http://eigen.tuxfamily.org">Eigen</a> seems nice. It has quite a few linear algebra operations embedded and seems <a rel="nofollow" class="external text" href="http://eigen.tuxfamily.org/index.php?title=Benchmark">very fast</a>.</li>
<li>Unify with the underlying routines of Numpy/Scipy <a rel="nofollow" class="external autonumber" href="http://www.scipy.org">[1]</a>
<ul><li>Some uBLAS/numpy bindings are available from <a rel="nofollow" class="external text" href="http://mathema.tician.de/software/pyublas">pyUlas</a>.</li></ul></li>
<li>See also the <a rel="nofollow" class="external text" href="http://www.itk.org/Wiki/Proposals:Sparse_Linear_Solvers">sparse linear solvers discussion page</a></li></ul></li>
<li>A fairly complete list of potential libraries can be found at <a rel="nofollow" class="external autonumber" href="http://verdandi.gforge.inria.fr/doc/linear_algebra_libraries.pdf">[2]</a></li>
<li>Numerical analysis package
<ul><li>The current numerical analysis package used by ITK is VNL. It's performance and robustness is not very good, it is not actively maintained. We should therefore discuss the alternative possibilities. Below is a list of potential alternatives:</li>
<li>The main numerical analysis tools we use from vnl are the optimizers. Most of these optimizers have an alternative quasi-ITK implementation in <a rel="nofollow" class="external text" href="http://elastix.isi.uu.nl/doxygen/a00448.html">elastix</a>.</li></ul></li></ul>
<h2><span class="mw-headline" id="Coding_Style">Coding Style</span></h2>
<ul><li>The current descriptive naming scheme is certainly good to get a grip on the functionality, but the length of the names are, IMHO getting a bit out of hand. I would suggest to group similar classes into namespaces, like e.g. MeanSquaresImageToImageMetric and MatchCardinalityImageToImageMetric, and the likes into ImageToImageMetric and use the specific part as new class name (MeanSquares, MatchCardinality).  For those preferring the long version ImageToImageMetric::MeanSquares is at least as descriptive, and others could use the using directive in their code. These namespaces would also help with the automatically generated documentation since classes would be better grouped by having namespace related pages instead of only the flat alphabetical ordering that currently exists. For backward compatibility, one could provide defines that should, of course, be only enabled as deprecated feature.</li></ul>
<ul><li>Currenty, all include files are included using only the file name and adding all the sub-directories of the ITK include tree to the search path. This adds quite some overhead to the compile time, since all these directories have to be searched. As an alternative I'd suggest to include the files like &lt;BasickFilter/itkSomeFilter.h&gt; or even change naming to &lt;itk/BasickFilter/SomeFilter.h&gt; and only add the itk include base path to the search path. As a result ...
<ul><li>the preprocessor only needs to find the subdirectory and then the file therein,</li>
<li>and in addition, if someone wants to look up something in the source code without firing up an IDE that automatically does the file lookup, it is easier to locate the include file based on this additional path information.</li>
<li>To make transition easier, one could define an extra CMAKE variable that would add the old include path for a backward compatible compile and in case of the second include style, let the old itkSomeFilter.h file emit a backward compatibility warning - just like g++ has warnings about e.g. including an old style &lt;iostream.h&gt; instead of the new &lt;iostream&gt;.</li></ul></li></ul>
<h2><span class="mw-headline" id="Wavelets_Framework">Wavelets Framework</span></h2>
<ul><li>Wavelets are intensively used in operations such as denoising and compressing. A common framework to decompose N-dimensionnal images with wavelets would be valuable. Such a framework could include&#160;:
<ul><li>a common way of representing wavelets,</li>
<li>a common way of representing multiscale images.</li></ul></li>
<li>See the following Insight Journal papers:
<ul><li><a rel="nofollow" class="external text" href="http://www.insight-journal.org/browse/publication/103">The Generalised Image Fusion Toolkit (GIFT)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.insight-journal.org/browse/publication/155">Spherical Wavelet ITK Filter</a></li></ul></li></ul>
<h2><span class="mw-headline" id="Label_map_writer">Label map writer</span></h2>
<ul><li>A class has been created to store labelmaps in memory, considering a writer/reader couple to store this information may be valuable.</li></ul>
<h2><span class="mw-headline" id="DICOM">DICOM</span></h2>
<p>Writing DICOM files should be much easier. Two modes should be available:
</p>
<ol><li>For basic user the DICOM image writer should write out simple DICOM file (Secondary Capture IOD's objects). This makes thoses DICOM file the exact equivalent of PNG or TIFF representation.</li>
<li>For advanced users: There should be a way for passing information from -say- the input DICOM files to the output DICOM files. Filters should be added to manipulate those meta data. Typical examples includes:
<ul><li>a derivation filter which add "DERIVED" and setup the Derivation Description, Source Image Sequence &amp; Derivation Code Sequence</li>
<li>a lossy generator that mark that image was degraded for professional interpretation and thus tags should be updated (Lossy Image Compression &amp; Lossy Image Compression Ratio)</li>
<li>changing of SOP Class should be allowed, for instance input is CT Image, but Segmentation Storage is needed for output (Registration Storage...)</li></ul></li></ol>
<p>For the advanced user, it will be possible to write out other class than just the Secondary Capture one, since there will be a way to specify which SOP Class to use for the output DICOM files.
</p>
<h2><span class="mw-headline" id="Support_clang_compiler">Support clang compiler</span></h2>
<ul><li>I'd like to be able to build ITK using the clang compiler (<a rel="nofollow" class="external free" href="http://clang.llvm.org/">http://clang.llvm.org/</a>)</li>
<li>CMake and GDCM can be built with clang, but ITK currently cannot.</li>
<li>clang itself can be built with CMake.</li>
<li>I have already created a dashboard <a rel="nofollow" class="external free" href="http://www.cdash.org/CDash/buildSummary.php?buildid=662643">http://www.cdash.org/CDash/buildSummary.php?buildid=662643</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20250111172927
Cache expiry: 86400
Reduced expiry: false
Complications: []
CPU time usage: 0.020 seconds
Real time usage: 0.022 seconds
Preprocessor visited node count: 81/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key KitwarePublicWikiDB:pcache:idhash:5601-0!canonical and timestamp 20250111172927 and revision id 31276. Serialized with JSON.
 -->
</div>
<div class="printfooter">Retrieved from "<a dir="ltr" href="https://public.kitware.com/Wiki/index.php?title=ITK_Release_4/Wish_List&amp;oldid=31276">https://public.kitware.com/Wiki/index.php?title=ITK_Release_4/Wish_List&amp;oldid=31276</a>"</div></div>
				<div id="catlinks" class="catlinks catlinks-allhidden" data-mw="interface"></div>
				<!-- end content --></body>
</html>